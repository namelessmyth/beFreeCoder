# 文档说明

本文档主要分享求职面试题。文档目前还在持续更新中，欢迎关注、收藏、点赞、加星喔😄O(∩_∩)O~。

同一个面试题往往会有很多种不同的问法，为了方便大家搜索，本文中面试题标题将尽量简洁，以涵盖同一面试题的不同问法。

| 文档名称     | 面试题-Java-MQ |
| ------------ | -------------- |
| 文档分类     | 求职-面试题    |
| 版本号       | 1.6            |
| 最后更新人   | Gem Shen       |
| 最后更新日期 | 2024-03-18     |
| 编制人       | Gem Shen       |
| 编制日期     | 2021-07-07     |




## 文档更新记录

| 版本 | 编制/修改人 | 修改日期   | 备注（原因、进一步的说明等）                         |
| ---- | ----------- | ---------- | ---------------------------------------------------- |
| 1.0  | Gem Shen    | 2021-07-07 | 初稿，整理了本次找工作积累到的所有面试题             |
| 1.1  | Gem Shen    | 2023-09-15 | 合并马士兵的面试笔记，重新整理目录结构               |
| 1.2  | Gem Shen    | 2023-09-19 | 整理Spring部分，将简历和沟通部分独立出去。           |
| 1.3  | Gem Shen    | 2023-09-30 | 完成Spring Framework面试题的初步整理。               |
| 1.4  | Gem Shen    | 2023-10-15 | 补充SpringBoot和SpringMVC面试题，将所有题目提升至3级 |
| 1.5  | Gem Shen    | 2023-12-18 | 文档过大，加载变慢，将每个一级标题单独拆分成一份文档 |
| 1.6  | Gem Shen    | 2024-03-18 | 补充RocketMQ和Karfka面试题                           |



# MQ

## 公共

### MQ使用场景

使用消息队列（MQ）适合以下使用场景：

1. 异步通信：当系统需要解耦合不同组件或服务之间的通信时，使用消息队列可以实现异步通信，提高系统的可伸缩性和灵活性。
2. 流量削峰：在高并发场景下，可以使用消息队列来缓解系统压力，实现流量削峰，避免系统崩溃或服务不可用。
3. 分布式系统集成：在分布式系统中，不同服务之间需要进行数据交换和通信，使用消息队列可以简化集成过程，提高系统的可靠性和稳定性。
4. 任务调度：对于需要定时执行或延迟执行的任务，可以将任务信息发送到消息队列中，由消费者进行处理，实现任务调度和分发。
5. 日志处理：对于大规模系统的日志处理，可以将日志信息发送到消息队列中，然后由消费者进行处理和存储，提高系统的日志处理效率。
6. 事件驱动架构：使用消息队列可以实现事件驱动架构，通过发布订阅模式来实现系统组件之间的通信和协作，提高系统的灵活性和可扩展性。

总之，消息队列适合于需要异步通信、流量削峰、分布式系统集成、任务调度、日志处理以及事件驱动架构等场景。



### MQ的优缺点

消息队列（MQ）的优缺点如下：

优点：

1. 解耦合：消息队列可以实现不同组件或服务之间的解耦合，提高系统的灵活性和可维护性。
   1. 例如：A系统调用B系统通过MQ发布订阅来解耦。如果B系统接口变更不会影响A，消费者或者生产者增减也不会影响。
2. 异步通信：通过消息队列实现异步通信，可以提高系统的响应速度和吞吐量。
3. 流量削峰：消息队列可以帮助系统实现流量削峰，缓解高并发场景下的压力。
4. 可靠性：消息队列通常具有消息持久化、消息重试机制、消息确认机制等特性，可以提高系统的可靠性和稳定性。
5. 扩展性：消息队列可以支持水平扩展，适应系统规模的增长。

缺点：

1. 复杂性：引入消息队列会增加系统的复杂性，需要额外的配置和管理，可能会增加系统的维护成本。
2. 一致性：在使用消息队列时，需要考虑消息的顺序性和一致性，可能会引入一些问题。
   1. 例如：每条消息只被处理1次，避免重复处理导致的不一致。
3. 延迟：由于消息队列是异步通信的机制，可能会引入一定的延迟，不适合对实时性要求较高的场景。
4. 数据一致性：在使用消息队列时，需要考虑消息的可靠性和一致性，可能会出现消息丢失或重复消费的情况。

总的来说，消息队列的优点包括解耦合、异步通信、流量削峰、可靠性和扩展性等，但也存在复杂性、一致性、延迟和数据一致性等缺点。在选择是否使用消息队列时，需要根据具体业务需求和系统架构来权衡利弊。



### MQ对比

对比RocketMQ、Kafka、RabbitMQ、ZeroMQ、ActiveMQ？



### MQ消息为什么重复

**第一类原因**

MQ接收消息并存储后，但由于种种原因，没有给发送端返回消息。发送端存在重试机制，重复发送消息。

1. MQ可能出现问题宕机
2. MQ可能因为负载高响应变慢，返回“成功”结果时超时。
3. MQ返回结果时网络出现问题，导致应用发送端重试，而重试时网络恢复。

**第二类原因**

MQ接收消息并存储后，进行向外的投递时，由于消费者成功处理完消息后，MQ没有及时更新投递状态造成的消费重复。

1. 消费者处理完消息后，应用出现问题。MQ不知道消息处理结果，再次投递。
2. 消费者处理完消息后，网络出现问题。MQ不知道消息处理结果，再次投递。
3. 消费者处理消息时间过长，MQ因为消息超时会再次投递。
4. 消费者处理完消息后，向MQ发送响应，此时MQ出现问题没有收到响应，再次投递。
5. 消费者处理完消息后，向MQ发送响应，MQ收到响应但没能更新投递状态成功，再次投递。

**如何解决**

主要是要求消费者来处理这种重复的情况，也就是要求消费者的消息处理是幂等操作。

**什么是幂等**

对于消息接收端的情况,幂等的含义是采用同样的输入多次调用处理函数,得到同样的结果。例如，一个SQL操作

update stat_table set count= 10 where id =1

这个操作多次执行,id等于1的记录中的 count字段的值都为10,这个操作就是幂等的,我们不用担心这个操作被重复。

再来看另外一个SQL操作

update stat_table set count= count +1 where id= 1;

这样的SQL操作就不是幂等的,一旦重复,结果就会产生变化。



## RocketMQ

### RocketMQ开源版本的功能限制

RocketMQ 开源版相对于企业版的功能限制：

**集群管理**

- **集群监控仪表盘：**开源版不提供可视化集群监控仪表盘。
- **集群自动伸缩：**开源版不支持基于指标的集群自动伸缩。
- **集群备份和恢复：**开源版不提供集群备份和恢复功能。

**消息特性**

- **消息顺序保证：**开源版仅支持部分有序消息，而企业版支持严格有序消息。
- **消息大小限制：**开源版的消息大小限制为 4MB，而企业版为 16MB。
- **消息回溯：**开源版不支持消息回溯，而企业版支持通过时间戳回溯消息。

**消息消费**

- **消费组管理：**开源版不提供可视化消费组管理界面。
- **消费进度管理：**开源版不提供消费进度管理功能。
- **消费重试策略：**开源版仅提供有限的消费重试策略，而企业版提供可定制的重试策略。

**消息生产**

- **生产者限流：**开源版不提供生产者限流功能。
- **消息批量发送：**开源版仅支持有限的消息批量发送，而企业版支持大批量发送。
- **消息发送超时：**开源版的消息发送超时时间较短，而企业版提供可定制的超时时间。

**其他**

- **企业支持：**开源版不提供官方企业支持，而企业版提供专业的技术支持。
- **数据安全：**开源版不提供加密和审计等数据安全功能，而企业版提供这些功能。
- **自定义扩展：**开源版提供的自定义扩展功能有限，而企业版提供丰富的扩展机制。
- **集群部署方式：**开源版仅支持单机部署，而企业版支持分布式部署。
- **社区支持：**开源版主要依赖社区支持，而企业版提供官方技术论坛和文档。



## Karfka





## RabbitMQ

### RabbitMq基本概念有哪些

     Broker：是指RabbitMQ提供的消息服务器。VHost：虚拟主机，为了解决服务相对独立的场景，提高了硬件资源利用率，也实现了资源的隔离和权限控制。Connection：无论是生产者发送消息，还是消费者接受消息， 都需要跟Broker建立一个TCP的长连接，就是Connection。Exchange：交换机，根据路由键路由消息给队列（可能是多个）Queue：队列，存生产者生产的消息的容器，RabbitMQ是使用数据库来存的。Consumer：消费者，消费消息，可以通过pull和push两种方式消费。Producer：生产者，生产消息Channel：应该是指一个TCP连接可以包含多个Channel，这样就不用使用多个TCP连接了，减少资源的消耗，channel是RabbitMQ原生API中最重要的接口。自定义交换机、队列、绑定关系这些都是调用的channel接口上的方法。

​    

### RabbitMq消息路由有哪些路由方式

    1. Direct：直接类型，全字匹配routingKey才能收到
    
    2. Topic：主题类型，模糊匹配routingKey，`*` 表示一个单词，`#` 零个或多个单词。单词以.区分
    
    3. Fanout：广播类型，不需要路由键和续写键，消息被发送到所有与交换机绑定的队列


​        

### 哪种场景下RabbitMQ会丢失数据。

    生产者发送消息给rabbitmq服务器的时候。由于网络原因丢失；
    
    消息到达rabbitmq服务器后，如果开启了持久化磁盘且磁盘满了数据也可能会丢失，设置了队列的最大数量的时候，还有消费端拿到了消息，但是没有正常消费，刚拿到就挂了等等
    
    消费端接收到消息后异常了。也可能导致消息丢失。



### RabbitMQ有哪些应答模式？

1. **手动应答（Manual Acknowledgement）**：消费者在处理完消息后，需要显式地发送应答给RabbitMQ，告知消息已经被成功处理。这种方式可以确保消息被正确处理，避免消息丢失或重复消费。手动应答可以通过调用`channel.basicAck(deliveryTag, multiple)`方法来实现，其中`deliveryTag`是消息的唯一标识，`multiple`表示是否批量确认。
2. **自动应答（Automatic Acknowledgement）**：消费者在接收到消息后，RabbitMQ会自动将消息标记为已经被消费，不需要显式地发送应答。这种方式适用于对消息的可靠性要求不高的场景，但可能会导致消息丢失或重复消费。
3. **拒绝消息（Reject and Requeue）**：消费者可以拒绝消息并要求重新入队列，这可以通过调用`channel.basicReject(deliveryTag, requeue)`方法来实现，其中`requeue`参数表示是否重新入队列。如果消息被重新入队列，会重新被投递给消费者。
4. **拒绝消息（Reject without Requeue）**：消费者可以拒绝消息并且不要求重新入队列，这可以通过调用`channel.basicReject(deliveryTag, false)`方法来实现。这种方式会将消息丢弃，不会重新投递给消费者。
5. **负面应答（Negative Acknowledgement）**：消费者可以通过Nack应答来拒绝消息，可以选择是否将消息重新入队列或者直接丢弃。可以通过`channel.basicNack(deliveryTag, multiple, requeue)`方法来实现。他比basicReject多一个参数，支持批量确认，允许消费者一次确认或拒绝多个消息。并且方法返回一个布尔值，表示操作是否成功。basicReject无返回值



### RabbitMQ中死信的应用场景

当使用 RabbitMQ 作为消息中间件时，死信队列（Dead Letter Exchange）是一个非常有用的功能，可以帮助处理一些特定的情况，提高系统的可靠性和灵活性。以下是一些更具体的应用场景和用途：

1. **消息消费失败重试：** 当消费者处理消息时发生异常或处理失败时，可以将该消息发送到死信队列。这样可以确保消息不会丢失，同时也可以实现消息的重试处理，直到成功消费为止。
2. **消息延时处理：** 可以通过设置消息的 TTL（Time-To-Live）属性，让消息在一定时间后自动发送到死信队列。这种方式可以实现消息的延时处理，比如实现定时任务、消息重试等功能。
3. **消息过期处理：** 可以设置消息的过期时间，在消息过期后将其发送到死信队列。这在一些场景下很有用，比如处理订单超时、任务超时等情况。
4. **消息路由失败处理：** 当消息无法被正确路由到目标队列时，可以将其发送到死信队列。这可以帮助排查和处理消息路由失败的情况，同时也可以进行针对性的处理。
5. **消息拒绝处理：** 当消费者拒绝处理某条消息时（比如消息格式错误、业务逻辑不符合等），可以将消息发送到死信队列。这样可以避免消息被丢弃，同时也可以进行后续的分析和处理。



### queue中消息数量限制？ 

默认情况下一般是无限制，因为限制取决于机器的内存，但是消息过多会导致处理效率的下降。

可以通过参数来限制， x-max-length ：对队列中消息的条数进行限制 ，x-max-length-bytes ：对队列中消息的总量进行限制



### channel、exchange和queue介绍与作用？

queue 具有自己的 erlang 进程；exchange 内部实现为保存 binding 关系的查找表；channel 是实际进行路由工作的实体，即负责按照 routing_key 将 message 投递给queue 。由 AMQP 协议描述可知，channel 是真实 TCP 连接之上的虚拟连接，所有AMQP 命令都是通过 channel 发送的。



## ZeroMQ

### ZeroMQ优缺点

**ZeroMQ 的优点：**

- **高性能：**ZeroMQ 是一款高性能的消息中间件，可以处理数百万条消息每秒。
- **低延迟：**ZeroMQ 的延迟非常低，通常在微秒级。
- **可扩展性：**ZeroMQ 可以轻松扩展到处理大量消息和连接。
- **灵活性：**ZeroMQ 提供了多种消息模式和传输协议，可以适应不同的使用场景。
- **跨平台：**ZeroMQ 支持多种编程语言和操作系统。

**ZeroMQ 的缺点：**

- **复杂性：**ZeroMQ 的 API 相对复杂，需要一定的时间来学习和掌握。
- **缺乏持久性：**ZeroMQ 不提供消息持久化功能，一旦消息被消费就会丢失。
- **社区支持有限：**与其他流行的消息中间件相比，ZeroMQ 的社区支持相对有限。
- **不支持事务：**ZeroMQ 不支持分布式事务，因此不适用于需要保证消息原子性、一致性、隔离性和持久性的场景。
- **不支持高可用：**ZeroMQ 本身不支持集群，需要使用第三方工具或库来实现。



### ZeroMQ应用场景

- **分布式系统：**构建分布式系统，实现不同组件之间的通信和消息传递。
- **实时数据处理：**处理来自不同来源的实时数据，如传感器、日志和社交媒体流。
- **游戏开发：**实现多人游戏中的玩家通信和数据同步。
- **金融交易系统：**构建高吞吐量、低延迟的金融交易系统。
- **物联网：**连接和管理物联网设备，实现数据采集和控制。

