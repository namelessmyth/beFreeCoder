# 文档说明

本文档主要分享求职面试题。文档目前还在持续更新中，欢迎关注、收藏、点赞、加星喔😄O(∩_∩)O~。

同一个面试题往往会有很多种不同的问法，为了方便大家搜索，本文中面试题标题将尽量简洁，以涵盖同一面试题的不同问法。

| 文档名称     | 求职-面试题-缓存 |
| ------------ | ---------------- |
| 文档分类     | 求职-面试题      |
| 版本号       | 1.0              |
| 最后更新人   | Gem Shen         |
| 最后更新日期 | 2024-03-07       |
| 创建人       | Gem Shen         |
| 创建日期     | 2024-02-27       |



# Redis

## 基础

### Redis为什么快？

**基于内存**：Redis 是一种基于内存的数据库，数据存储在内存中，数据的读写速度非常快，因为内存访问速度比硬盘访问速度快得多。

**单线程模型**：Redis 使用单线程模型，这意味着它的所有操作都是在一个线程内完成的，不需要进行线程切换和上下文切换。这大大提高了 Redis 的运行效率和响应速度。

**I/O多路复用**：Redis在单线程的基础上，采用了I/O多路复用技术，实现了单个线程同时处理多个客户端连接的能力，从而提高了 Redis 的并发性能。

**高效的数据结构**：Redis 提供了多种高效的数据结构，如哈希表、有序集合、列表等，这些数据结构都被实现4.得非常高效，能够在 O(1)的时间复杂度内完成数据读写操作，这也是 Redis 能够快速处理数据请求的重要因素之一。

**多线程的引入**：在Redis 6.0中，为了进一步提升IO的性能，引入了多线程的机制。采用多线程，使得网络处理的请求并发进行，就可以大大的提升性能。多线程除了可以减少由于网络IO等待造成的影响，还可以充分利用 CPU 的多核优势。



### 为什么Redis用单线程就快

Redis 采用单线程模型的设计主要有以下几个原因，同时也是导致 Redis 单线程模型高效的关键因素：

1. **减少线程切换开销**：多线程模型在切换线程时需要保存和恢复线程上下文，这会导致额外的开销。而 Redis 的单线程模型避免了线程切换的开销，使得系统更加高效。
2. **避免锁竞争**：在多线程模型中，不同线程之间可能会竞争锁，导致性能下降。Redis 的单线程模型避免了锁竞争，减少了竞争带来的性能损失。
3. **利用非阻塞IO**：Redis 使用非阻塞IO模型，单线程可以处理多个客户端请求，通过事件循环机制高效地处理IO操作，提高了系统的响应速度。非阻塞 I/O 通常指的是利用 I/O多路复用技术来实现
4. **内存操作效率高**：Redis 是基于内存的数据库，内存操作速度非常快。单线程模型可以充分利用内存操作的高效率，提高系统的性能。

综合以上因素，Redis 的单线程模型在处理高并发读写请求时能够保持高效率，提供快速的响应速度，使得 Redis 在许多场景下都能够表现出色。



### Redis是CP还是AP？

设计目标：Redis的设计目标是高性能、高可扩展性和高可用性，Redis的一致性模型是最终一致性，即在某个时间点读取的数据可能并不是最新的，但最终会达到一致的状态。

没办法保证强一致性的主要原因

**异步复制**：Redis分布式设计中采用的是异步复制，这导致在节点之间存在数据同步延迟和不一致的可能性。

**网络延迟**：如果主节点和从节点之间的网络出现延迟或丢包，复制过程中可能会有数据同步的延迟，从而导致从节点上的数据不是最新的。

**故障转移**：主节点发生故障时，Redis 会进行故障转移将一个从节点提升为新的主节点。在这个过程中，可能会有一小段时间内数据不一致，直到新主节点完全接管主节点的角色。

**节点故障**：当Redis单节点发生故障时，这个节点上的数据可能无法同步到其他节点，这就可能导致数据在节点之间的不一致。虽然Redis通过复制和哨兵等机制可以提高系统的可用性和容错性，但是这些机制并不能完全解决数据一致性问题。

如果启用同步复制呢？也不能完全保证强一致性。在同步复制中，主节点在执行写操作时会等待至少一个从节点确认接收到该写操作后才继续执行，这可以提高数据一致性的概率，但并不能完全保证强一致性。



### 请说明Redis基本数据类型底层的数据结构

String

SDS，简单动态字符窜。他是redis自己实现的一个字符窜格式。解决了C语言字符数据的种种不足。

例如：\0，必须要循环才能知道字符长度。

有三种编码格式。

int，存储8个字节的长整型，long，2^63^-1

embstr，存储小于44字节的字符

raw，存储大于44字节的字符


​    

Hash

ziplist+hashtable

满足如下条件就是ziplist，否则就是hashtable

1. 键值对数量<512
2. 每一个键值对都小于64字节


​    

List

quicklist+ziplist，quicklist是双向链表，里面每一个节点是ziplist


​    

Set

intset+hashtable

满足如下条件用intset，否则就是hashtable

每一个元素都必须是int

元素个数小于512（可配置）

hashtable中的value为空。




ZSet

ziplist+skiplist，如果元素个数大于128，或者任意一个元素大于64字节就使用skiplist，否则默认使用ziplist




### Redis中Key和Value的最大容量是多少？

redisKey：512m；

Value要区分类型

String的value存储最大位512m

list中value存储最大为2^32-1（约40亿左右）



### Redis中Key和Value有哪些设计原则

Key 的设计原则

1. 可读性:一个Key应该具有比较好的可读性，让人能看得懂是什么意思，而不是含糊不清。key 名称以key所代表的 value 类型结尾，以提高可读性。例如: `user:basic.info:userid:string` 。
2. 简洁性:Key 应该保持简洁，避免过长的命名，以节省内存和提高性能。一个好的做法是使用短、有意义的Key，但也不要过于简单以避免与其他Key冲突。
3. 避免特殊字符:避免在 Key 中使用特殊字符，以确保 Key 的可读性和可操作性。命名中尽量只包含:大小写字母、数字、竖线、下划线、英文点号(.)和英文半角冒号(:)。
4. 命名空间:使用命名空间来区分不同部分的Key。例如，可以为用户数据使用"user:"前缀，为物料数据使用"item:" 前缀。
5. 长度限制:避免在 Key 的长度过长，会占用内存空间。

Value 的设计原则

数据类型选择:根据数据的特性选择合适的数据格式。Redis支持字符串、列表、哈希、集合和有序集合等多种数据类型，选择合适的数据格式可以提高操作效率

避免大Key:如果Value很大，那么对应的Key就称之为大Key，大Key会带来很多问题应该尽量避免。可以尝试将大数据分割为多个小 Value，以提高性能和降低内存使用。



### 大Key问题的影响和解决?

Big Key是值Redis中存储了大量数据的Key，big key不只是表示Key值很大，还包括这个Key对应的value占用空间很多的情况，通常在String、list、hash、set、zset等类型中出现的问题比较多。其中String类型就是字符串的值比较大，而其他几个类型就是其中元素过多的情况。

Redis的Big Key可能存在以下几个危害:

1、影响性能：由于big key的values占用的内存会很大，所以读取它们的速度会很慢，会影响系统的性能.

2、占用内存：大量的big key也会占满Redis的内存，让Redis无法继续存储新的数据，而且也会导致Redis卡住

3、内存空间不均匀:比如在 Redis 集群中，可能会因为某个节点上存储了Big Key，导致多个节点之间内存使用不均匀。

4、影响Redis备份和恢复:如果从RDB文件中恢复全量数据时，可能需要大量的时间，甚至无法正常恢复.

5、搜索困难:由于大key可能非常大，因此搜索key内容时非常困难，并且可能需要花费较长的时间完成搜索任务。

6、迁移困难:大对象的迁移和复制压力较大，极易破坏缓存的一致性

7、过期执行耗时:如果 Bigkey 设置了过期时间，当过期后，这个 key 会被删除，而大key的删除过程也比较耗时

多大算BigKey？

通常情况下，建议不要超过以下设定，超过这些数量就可能会影响Redis的性能.

对于 String 类型的 Value 值，值超过 5MB(腾讯云定义是10M，阿里云定义是5M)。

对于 Set 类型的 Value 值，含有的成员数量为 10000 个(成员数量多)。

对于 List 类型的 Value 值，含有的成员数量为 10000 个(成员数量多)。

对于 Hash 格式的 Value 值，含有的成员数量 1000 个，但所有成员变量的总 Value 值大小为100MB(成员总的体积过大)。

但是，这些并不是绝对的限制，而是一个经验值，具体的情况还需要根据应用场景和实际情况进行调整。



### Redis常用数据类型及使用场景

Redis 常用的数据类型有

1. **String（字符串）**：
   - 数据结构：简单的键值对，存储字符串值。
   - 使用场景：缓存数据、分布式锁、计数器、配置信息、会话管理、全局ID等。
2. **Hash（哈希）**：
   - 数据结构：类似于对象，存储字段和值的映射关系。
   - 使用场景：存储对象类型数据，例如：购物车、用户信息、商品信息、配置信息等。
3. **List（列表）**：
   - 数据结构：有序列表，支持头部和尾部插入、删除操作。
   - 使用场景：消息队列、任务队列、最新消息列表，文章列表，公告列表等。
4. **Set（集合）**：
   - 数据结构：无序且唯一的字符串集合。
   - 使用场景：标签系统、好友关系、共同喜好、抽奖，用户关注，点赞，签到打卡等。
5. **ZSet（有序集合）**：
   - 数据结构：类似于集合，但每个元素关联一个分数，按照分数排序。
   - 使用场景：排行榜、范围查询、优先级队列、百度热搜等。
6. **Bitmap**：
   - 数据结构：位图，每个位可以表示某种状态或标记。
   - 使用场景：用户签到、在线用户状态、用户活跃度统计等。
7. **HyperLogLog**：
   - 数据结构：用于估计基数（不重复元素）的数据结构。
   - 使用场景：统计独立访客数量、UV统计（Unique Visitors 独立访客数量的统计）、数据去重等。
8. **GeoSpatial**：
   - 数据结构：存储地理位置信息的数据结构。
   - 使用场景：附近的人、地理位置搜索和计算、地理围栏等。



### Redis中String的底层结构？优势在哪

SDS：简单动态字符串；

优势：

存储了字符窜长度，不需要循环遍历来获得长度。

可以通过长度来判断循环是否结束，而不是根据\0判断，更加可靠

支持扩容，有空间预分配和惰性空间释放机制



### 缓存雪崩

缓存雪崩是指在同一时间大量缓存失效，导致大量请求直接访问后端数据库，给后端造成巨大压力，甚至导致后端崩溃。

**原因：**

- **缓存同时失效：** 当大量缓存键在同一时间失效时，就会发生缓存雪崩。这可能是由于缓存过期策略不当或缓存服务器故障造成的。
- **热点数据集中失效：** 如果大量的热点数据（被频繁访问的数据）在同一时间失效，也会导致缓存雪崩。

**解决方案：**

- **使用不同的过期时间：** 比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。
- **使用渐进式过期：** 例如：第一个失效时间10秒，第2个12秒，第3个14秒。。。
- **缓存不过期：** 这样就不会出现失效的问题，但是随之而来的就是Redis 需要更多的存储空间。
- **保持缓存层的高可用性：** 使用Redis 哨兵模式或者Redis 集群部署方式，即便个别Redis 节点下线，整个缓存层依然可以使用。除此之外，还可以在多个机房部署 Redis，这样即便是机房死机，依然可以实现缓存层的高可用。



### 缓存击穿

缓存击穿是指当某个热点数据失效时，大量请求并发访问后端数据库，给后端造成巨大压力。

**原因：**

- **热点数据失效：** 当热点数据失效时，所有对该数据的请求都会直接访问后端数据库。
- **并发请求：** 如果同时有多个请求访问失效的热点数据，就会导致缓存击穿。

**解决方案：**

- **使用互斥锁：** 在缓存失效时，使用互斥锁防止并发请求同时访问后端数据库。
  - 例如：使用Redis的分布式锁来控制同时只有一个请求可以去后端获取数据
- **热点数据永不过期**：对于热点数据将其设置为永不过期，就不存在这个问题了。
- **设置逻辑过期时间：** 逻辑过期就是给缓存的数据添加一个逻辑过期字段，而不是真正的给它设置一个TTL。每次查询缓存的时候去判断是否已经超过了我们设置的逻辑过期时间，如果未过期，直接返回缓存数据；如果已经过期则进行缓存重建。。



### 缓存穿透

缓存穿透是指查询一个根本不存在于缓存和后端数据库中的数据，导致每次请求都直接访问后端数据库。

**原因：**

- **恶意攻击：** 攻击者可能故意查询不存在的数据，以耗尽后端资源。
- **缓存未命中：** 查询的数据可能从未被缓存过，或者由于某种原因从缓存中被删除了。

**解决方案：**

- **使用布隆过滤器：** 在缓存之前使用布隆过滤器，快速判断数据是否存在。如果不存在，则直接返回，避免查询后端数据库。
- **设置默认值：** 第一次查询后，为不存在的数据设置默认值，以避免每次都查询后端数据库。但空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间(如果是攻击，问题更严重),比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。



### 可能发生分布式死锁的案例

假设有两个账户A和B，转账操作需要先锁定账户A，然后锁定账户B，执行转账操作，最后释放两个账户的锁。

如果两个客户端同时尝试进行转账操作，可能会导致死锁的情况：

1. 客户端1先锁定账户A，然后尝试锁定账户B。
2. 同时，客户端2先锁定账户B，然后尝试锁定账户A。

在这种情况下，客户端1持有账户A的锁，客户端2持有账户B的锁，但双方都无法获取对方持有的锁。因此，客户端1无法继续锁定账户B，客户端2也无法继续锁定账户A，导致双方互相等待对方释放锁，形成死锁。

解决方案：使用非阻塞锁，在Redission中调用lock.tryLock()方法。



### 使用分布式锁需要考虑哪些问题

**使用分布式锁需要考虑的问题以及解决方案：**

**1. 死锁：**多个客户端同时获取锁，导致互相等待，形成死锁（[案例介绍](#可能发生分布式死锁的案例)）。

- 使用非阻塞锁：Redis 的 `SETNX` 命令可以实现非阻塞锁，只有当锁不存在时才能获取成功。（Redission中：lock.tryLock()）
- 设置锁过期时间：为锁设置一个过期时间，如果持有锁的客户端崩溃或网络中断，锁会自动释放。

**2. 锁过期：**锁的持有时间过长，导致其他客户端无法获取锁。

- 使用 `SETEX` 命令设置锁的过期时间，避免锁持有时间过长。
- 使用看门狗机制：定期检查锁和客户端，当出现锁过期，客户端异常等情况时，可以自动获取新的锁或释放无效的锁。

**3. 锁粒度：**锁的粒度过大或过小，影响并发性和性能。

- 根据业务需求合理设置锁的粒度，既要保证并发性，又要避免锁竞争。
- 使用分层锁：将锁划分为多个层次，根据不同的业务场景使用不同粒度的锁。

**4. 高可用性：**分布式锁服务需要保证高可用性，避免单点故障。

- 建议使用Redis Cluster 等高可用性解决方案，确保分布式锁服务的高可用性。 Redis Sentinel 不建议
- 如果对高可用性要求很高，可以考虑使用redlock。

**5. 性能：**获取和释放锁的操作需要高效，避免影响系统性能。

- 使用 Lua 脚本实现分布式锁，可以原子化地执行获取和释放锁的操作，提高性能。
- 使用 Redis 的 `EVAL` 命令执行 Lua 脚本，避免网络开销。
- 使用Redission客户端时，他会自动调用Lua脚本。

**示例：**

```lua
-- 获取锁
local key = "my_lock"
local ttl = 10 -- 锁的过期时间（秒）
if redis.call("setnx", key, 1) == 1 then
    redis.call("expire", key, ttl)
    return true
else
    return false
end

-- 释放锁
redis.call("del", key)
```

通过使用上述方法，可以在 Redis 中有效地解决分布式锁的常见问题，确保分布式系统的可靠性和性能。



### Redis的分布式锁怎么使用

setnx命令+lua脚本，同时加上redis的单线程命令执行

在 Spring Boot 中基于 Redisson 实现分布式锁的步骤如下：

1. 引入 Redisson 依赖，并配置好Redisson（步骤略）
2. 使用Redisson获取分布式锁：注入 `RedissonClient` 对象，并使用该对象获取分布式锁。代码如下：

```java
@Service
public class DistributedLockService {

    @Autowired
    private RedissonClient redissonClient;

    public void doWithDistributedLock() {
        RLock lock = redissonClient.getLock("myLock");
        try {
            lock.lock();
            // 执行需要加锁的业务逻辑
        } finally {
            lock.unlock();
        }
    }
}
```

在上述代码中，通过 `redissonClient.getLock("myLock")` 获取一个名为 "myLock" 的分布式锁，并在需要加锁的业务逻辑中使用 `lock.lock()` 和 `lock.unlock()` 来获取和释放锁。



### lua脚本的使用场景及优缺点

Lua脚本在Redis中的使用场景包括：

1. **原子性操作**：通过Lua脚本可以实现多个Redis命令的原子性操作，避免在多个命令之间发生竞态条件。
2. **复杂计算**：可以利用Lua脚本在Redis服务器端执行复杂的计算逻辑，减少网络传输开销。
3. **减少网络开销**：将多个命令封装在Lua脚本中一次性执行，减少客户端与服务器之间的网络开销。
4. **事务支持**：Lua脚本可以在Redis的事务中执行，确保一系列操作的原子性。

优点：

- **原子性**：Lua脚本可以保证多个Redis命令的原子性操作。
- **性能**：减少网络传输开销，提高性能。
- **灵活性**：可以在Redis服务器端执行复杂的计算逻辑。

缺点：

- **维护性**：Lua脚本的编写和维护相对复杂。
- **可读性**：Lua脚本可能难以理解，降低了代码的可读性。
- **调试**：Lua脚本的调试相对困难，不如在客户端直接调试Redis命令方便。

Lua 脚本在 Redis 中是可以被禁用的。通过配置文件或者在 Redis 命令行中设置参数，可以禁用 Lua 脚本的执行。禁用 Lua 脚本可能会对一些功能造成影响，因为一些 Redis 命令可能依赖 Lua 脚本来实现特定的功能。在一些安全性要求较高的环境下，禁用 Lua 脚本可能是一个必要的安全措施。

在分布式锁的实现中，Lua 脚本的作用是确保获取锁的操作是原子性的，即在获取锁的过程中，设置锁的值和设置锁的过期时间是一个不可分割的操作。这样可以避免在多个 Redis 命令之间发生竞争条件，确保获取锁的操作的一致性和可靠性。

不过，如果是使用Redisson，他内部会使用 Lua 脚本来执行获取锁的操作，保证了获取锁的原子性。它会将获取锁、设置锁的值和设置锁的过期时间等操作封装在一起，并通过 Lua 脚本一次性发送到 Redis 服务器执行，确保操作的原子性和一致性。



### redlock的使用场景

建议在以下场景下使用 Redlock 而不是普通的分布式锁：

1. **对可用性要求较高的场景**：Redlock 算法通过在多个 Redis 实例上获取锁，并使用大多数原则来确保锁的可靠性和一致性，适用于对系统可用性要求较高的场景。如果系统对可用性要求很高，可以考虑使用 Redlock 算法提高锁的可靠性。
2. **需要避免单点故障的场景**：普通的分布式锁可能存在单点故障的风险，如果锁的持有者节点发生故障，可能导致锁无法释放或其他节点无法获取锁。而 Redlock 算法通过在多个 Redis 实例上获取锁，可以避免单点故障的问题。
3. **需要更高的锁可靠性和一致性的场景**：Redlock 算法通过在多个 Redis 实例上获取锁，并使用大多数原则来确保锁的可靠性和一致性，可以提供更高的锁可靠性和一致性。在对锁的可靠性和一致性要求较高的场景下，可以选择使用 Redlock 算法。
4. **对并发控制要求严格的场景**：在一些对并发控制要求较严格的场景下，普通的分布式锁可能无法满足要求。Redlock 算法可以提供更可靠的并发控制机制，确保在高并发情况下仍能正确地控制资源访问。

总的来说，建议在对系统可用性要求高、需要避免单点故障、对锁的可靠性和一致性要求高、以及对并发控制要求严格的场景下使用 Redlock 而不是普通的分布式锁。通过使用 Redlock 算法，可以提高锁的可靠性和一致性，确保系统在分布式环境下能够正确地进行并发控制。



### 延迟双删



### redis内存耗光会怎么样？

 这个问题其实就是问的淘汰策略，把8种淘汰策略都说出来就行了。让用户自行选择。默认是noeviction



### Redis过期策略

过期策略主要针对设置了过期时间的key，策略分为三类，立即策略、惰性策略和定期策略。

Redis默认同时开启定期删除和惰性删除两种过期策略，不会到期立即删除过期key

#### 立即策略

含义：

也叫定时策略，在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除。

优点：

保证内存被尽快释放，减少无效的缓存占用内存。

缺点：

若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key。

定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重。一般来说，是不会选择该策略模式。 

#### 惰性策略

含义：

key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。

写入Key的时候，当发现内存不足时，也会释放一部分内存空间（调用activeExpireCycle）

expire.c 123行

> activeExpireCycle(int type)

优点：

删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）。

缺点：

若大量的key在超出过期时间后，但没有被访问过就不会被清除，那么可能发生内存泄露（无用的垃圾占用了大量的内存）。 

#### 定期策略

含义：每隔一段时间对设置了过期时间的key进行检测，从里面随机挑选部分已过期key，从内存中删除。设置了过期时间的key存在redis的expire字典中。server.h 661行

优点：

通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用--处理"定时删除"的缺点

定期删除过期key--处理"惰性删除"的缺点。

缺点:

在内存友好方面，不如"定时删除"，因为是随机遍历一些key，因此存在部分key过期，但遍历key时，没有被遍历到，过期的key仍在内存中。

在CPU时间友好方面，不如"惰性删除"，定期删除也会暂用CPU性能消耗。

难点:

合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了）

#### 总结

Redis同时使用了惰性策略和定期策略，并不会到期立即删除过期key


​    

### Redis淘汰策略

**淘汰策略是什么**？

redis中还有很多Key没有设置过期时间，通过过期策略也不能保证内存不会满。所以还需要淘汰策略。

Redis当内存使用达到最大内存极限时，需要使用淘汰算法来决定清理掉哪些数据，以保证新数据的存入。

**使用建议**：

腾讯针对Redis的淘汰策略设置给出的建议：

- 当 Redis 作为缓存使用的时候，推荐使用 alkeys-lru 淘汰策略。该策略会将最近最少使用的 Key 淘汰。默认情况下，使用频率最低则后期命中的概率也最低，所以将其淘汰。
- 当 Redis 作为半缓存半持久化使用时，可以使用 volatile-lru。但因为 Redis 本身不建议保存持久化数据所以只作为备选方案。

阿里云Redis默认是volatile-lru

**淘汰策略介绍**

主要分为如下六种淘汰机制。

从前缀针对的对象来分: volatile是针对设置了过期时间的 key，allkeys是针对所有key。

LRU，LFU，RANDOM，TTL。

##### volatile-lru

当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。

##### allkeys-lru

当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）。

##### volatile-lfu

当内存不足以容纳新写入数据时，在过期密集的键中，使用LFU算法进行删除key。

##### allkeys-lfu

当内存不足以容纳新写入数据时，使用LFU算法移除所有的key。

##### volatile-random

当内存不足以容纳新写入数据时，在设置了过期的键中，随机删除一个key。

##### allkeys-random

当内存不足以容纳新写入数据时，随机删除一个或者多个key。

##### volatile-ttl

当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

##### noeviction

默认的淘汰策略。对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）。




### Redis持久化的方式有哪些，有什么区别

#### RDB

RDB是Redis默认的持久化方案（注意如果开启了AOF，优先用AOF)。当满足一定条件的时候，会把当前内存中的数据写入磁盘，生成一个快照文件dump.rdb。Redis重启会通过加载dump.rdb文件恢复数据。

**触发条件**

自动触发

1. 配置规则触发。满足什么条件触发RDB，例如：save 900 1 #900秒内至少有一个key被修改
2. shutdown触发，如果shutdown的时候，内存中还有key没有持久化就触发rdb。
3. flushAll触发，但实际没啥意义，因为生成的rdb文件是空的

手动触发

1. save

    阻塞服务器直到服务器生成快照结束。生产环境不建议使用这个命令，可能会造成redis长时间阻塞。	

2. bgsave

    在后台异步生成快照，不会阻塞。

**RDB优劣**

**优势**

1. RDB是一个非常紧凑(compact)的文件，它保存了redis在某个时间点上的数据集。这种文件非常适合用于进行备份和灾难恢复。
2. 生成RDB文件的时候，redis 主进程会 fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。
3. RDB 在恢复大数据集时的速度比AOF的恢复速度要快。

**劣势**

1. RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork 操作创建子进程，频繁执行成本过高
2. 在一定间隔时间做一次备份，所以如果redis意外down 掉的话，就会失去最后一次快照之后的所有修改（数据有丢失)。如果数据相对来说比较重要，希望将损失降到最小，则可以使用AOF方式进行持久。


​    

#### AOF

AOF: Redis 默认不开启。AOF 采用日志的形式来记录每个写操作，并追加到文件中。开启后，执行更改Redis数据的命令时，就会把命令写入到AOF文件中。写入频率可配置，默认每隔一秒写入一次。

Redis重启时会根据日志文件的内容把写指令从前到后执行一次以完成数据的恢复工作。

当文件越来越大时，如果满足一定条件，Redis会触发重写机制。用最小指令集来替换原来的AOF文件。

AOF优劣

优势

AOF 持久化的方法提供了多种的同步频率，即使使用默认的同步频率每秒同步一次，Redis最多也就丢失1秒的数据而已。

劣势

1. 对于具有相同数据的的Redis，AOF文件通常会比RDF 文件体积更大(RDB存的是数据快照)。
2. 虽然AOF提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较高的性能。
3. 在高并发的情况下，RDB比AOF具好更好的性能保证。

RDB和AOF比较

如果可以接受一小段时间内数据的丢失，毫无疑问使用RDB是最好的。

定时生成RDB快照(snapshot)非常便于进行数据库备份，并且RDB恢复数据集的速度也要比AOF恢复的速度要快。

否则就使用AOF重写。但是一般情况下建议不要单独使用某一种持久化机制，而是2种一起用。在这种场景下，redis会优先使用aof文件来恢复原始数据。通常情况下，aof备份的数据要比rdb更完整。



### Java连接Redis的客户端对比

**Spring Data Redis**、**Redisson**、**Jedis** 和 **Lettuce** 都是 Java 客户端，用于连接和操作 Redis 服务器。以下是它们的对比：

**连接池：**

- **Spring Data Redis：** 使用 Jedis 或 Lettuce 作为其底层连接池。
- **Redisson：** 使用 Netty 作为其底层连接池。
- **Jedis：** 使用 JedisPool 作为其连接池。
- **Lettuce：** 使用 Netty 或 Reactor 作为其底层连接池。

**数据结构支持：**

- **Spring Data Redis：** 提供对基本数据结构（如字符串、列表、映射和集合）的高级抽象。
- **Redisson：** 支持广泛的数据结构，包括对象、列表、映射、集合、有序集合和原子变量。
- **Jedis：** 支持基本的数据结构，如字符串、列表、映射和集合。
- **Lettuce：** 支持基本的数据结构，如字符串、列表、映射和集合，以及一些额外的功能，如流和事务。

**命令支持：**

- **Spring Data Redis：** 通过其高级抽象层支持 Redis 的大多数命令。
- **Redisson：** 支持 Redis 的所有命令，包括发布/订阅、事务和脚本。
- **Jedis：** 支持 Redis 的大多数命令，但缺少对某些命令的支持，如发布/订阅和事务。
- **Lettuce：** 支持 Redis 的大多数命令，包括发布/订阅、事务和脚本。

**异步操作：**

- **Spring Data Redis：** 通过 Lettuce 提供异步支持。
- **Redisson：** 提供异步 API，允许非阻塞操作。
- **Jedis：** 不提供异步 API。
- **Lettuce：** 提供异步 API，允许非阻塞操作。

**其他特性：**

- **Spring Data Redis：** 提供对 Spring 框架的集成，简化了 Redis 的使用。
- **Redisson：** 提供分布式锁、原子计数器和分布式队列等附加功能。
- **Jedis：** 提供一些基本功能，如管道和事务。
- **Lettuce：** 提供管道、事务、流和地理空间支持等附加功能。

**总结：**

- **Spring Data Redis：** 适用于需要与 Spring 框架集成、高级数据结构抽象和异步支持的应用程序。
- **Redisson：** 适用于需要高性能、可伸缩性和广泛数据结构支持的应用程序。
- **Jedis：** 适用于需要基本 Redis 操作和连接池功能的简单应用程序。
- **Lettuce：** 适用于需要高性能、异步操作和附加功能（如流和地理空间支持）的应用程序。

**选择指南：**

- 如果需要与 Spring 框架集成和高级数据结构抽象，**Spring Data Redis** 是一个不错的选择。
- 如果需要高性能、可伸缩性和广泛的数据结构支持，**Redisson** 是一个不错的选择。
- 如果需要基本 Redis 操作和连接池功能，**Jedis** 是一个不错的选择。
- 如果需要高性能、异步操作和附加功能，**Lettuce** 是一个不错的选择。


​    



## 高可用集群

### Redis哨兵机制的原理

哨兵+主从实现Redis集群高可用
集群监控:负责监控Redis master和slave进程是否正常工作
消息通知:如果某个Redis实例有故障，哨兵负责发送消息给管理员进行报警
故障转移: master宕机后，Redis集群会自动将master身份转移到slave节点
配置中心:如果故障转移发生了，通知client客户端新的master地址



### Redis主从同步原理

启动一台slave实例后，slave会发送一个psync命令给master，如果该slave是第一次连接到master，那么就会触发一个全量复制,master节点fork一个子进程生成RDB快照，在快照生成过程中，会把新的请求全部写到Redis缓冲池中，RDB文件生成之后，master会将文件发送到slave, slave拿到文件后写入本地磁盘，然后再加载到内存中，待RDB文件同步完成后，会通知master， master再将缓冲池中新的写命令发送到slave进行同步，待完成后slave正式进入集群对外提供服务


​    

### Redis高可用方案有哪些？建议用哪个？为什么

Redis有几种高可用方案，包括：

1. **Redis Sentinel**：Redis 官方提供的监控和自动故障转移解决方案，用于实现 Redis 的高可用性。Redis Sentinel 可以监控 Redis 实例的健康状态，并在主节点故障时自动进行故障转移。
2. **Redis Cluster**：Redis 提供的分布式解决方案，可以将数据分片存储在多个节点上，实现数据的水平扩展和高可用性。Redis Cluster 在节点故障时能够自动进行故障转移和数据重分配。
3. **Redisson**：Redisson 是一个基于 Redis 的 Java 驱动库，提供了对分布式锁、分布式集合等功能的支持，同时也提供了高可用性解决方案。Redisson 可以通过配置使用 Redis Sentinel 或 Redis Cluster 来实现高可用性。
4. **第三方云厂商提供的 Redis 托管服务**：云厂商如 AWS、Azure、阿里云等提供了 Redis 的托管服务，包括自动备份、自动故障转移、多可用区部署等功能，可以保障 Redis 服务的高可用性。

最推荐使用的高可用方案包括 Redis Cluster 和第三方云厂商提供的 Redis 托管服务。这两种方案能够提供较好的高可用性和可靠性，同时支持数据的水平扩展和自动故障转移，适合大规模生产环境下对 Redis 服务高可用性要求较高的场景。使用 Redis Cluster 可以实现数据的分片存储和自动故障转移，而选择云厂商提供的 Redis 托管服务可以让用户专注于业务逻辑而无需关心底层 Redis 的运维工作。


​    

### 说说Redis的哈希槽概念

    Redis 集群没有使用一致性hash，而是引入了哈希槽（slot）的概念。
    
    Redis 集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽。
    
    集群的每个节点负责一部分hash槽。再通过上面得到槽位就将key放置到节点。
    
    使用哈希槽的好处就在于可以方便的添加或移除节点。不会造成集群不可用的状态。
    
    当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；
    
    当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了；
    
    在这一点上，我们以后新增或移除节点的时候不用先停掉所有的 redis 服务。

### redis集群，为什么是16384个slot？

     (1)因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。
    
      在消息头中，有一个存储当前分片管理槽位的字节数组` myslots[CLUSTER_SLOTS]`。
    
     如果槽位为65536，这个数组将达到8KB（ 65536÷8÷1024=8kb）
    
      (2)redis的集群主节点数量基本不可能超过1000个。
      如上所述，集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者，不建议redis cluster节点数量超过1000个。
      那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。
      (3)槽位越小，节点少的情况下，压缩比高
      Redis主节点的配置信息中，它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中，会对bitmap进行压缩，但是如果bitmap的填充率slots / N很高的话(N表示节点数)，bitmap的压缩率就很低。
      如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。



### redis主从复制过程以及原理

首先slave与master建立连接，slave会在本地保存master的ip和端口，通过定时任务检测是否有master节点需要连接和复制；
    
然后slave通过定时ping与master建立通信，告诉master自己存活；如果slave在成为master从节点之前有数据，则会删除自身数据，保证和master的一致性；
    
通过RDB进行全量复制，在RDB过程中继续写入的命令会加入的缓存中，和RDB一起发送的slave节点；
    
后续会根据偏移量等节点信息来进行增量复制；


### Redis哨兵机制如何实现故障自动转移

     首先哨兵集群需要选举一个leader来进行redis节点的master节点选举与数据同步等操作；
    
     leader选举过程：通过raft算法进行选举，先到先得，少数服从多数；
    
     1、所有的sentinel初始都为跟随者，首先用random随机数为所有跟随者，设置一个倒计时时间，150ms~300ms，第一个倒计时结束的会成为候选者，候选者会发起投票，超过半数票给了自己，那么自己成为leader，后续所有操作由leader完成；
    
     2、leader记录操作日志并发给其他sentinel节点，没有同步到其他节点的日志，状态为uncommitted，等到超过了半数节点记录了日志，则变为committed，leader会通知其他节点日志已经提交，这样所有节点达成一致；
    
     3、节点只要收到了同步数据的消息，代表leader产生，就会取消倒计时；
    
     4、如果倒计时结束，还没有获得超过半数进行投票，那么重置倒计时，直至选出leader；
    
     5、如果倒计时一样，产生两个候选者，那么同时发出投票，先各自投自己一票，然后随机获取倒计时时间，发起新一轮选举，由于倒计时不一致，先获得更多投票的节点成为leader；
    
     选举出leader然后进行master选举：
    
     根据几条规则进行选举：节点是否存活、优先级、偏移量、进程id；
    
     1、通过心跳检测节点，超过时间，则认为节点出现故障，失去选举权；
    
     2、配置文件可以设置优先级，优先级高的成为master，默认一致；
    
     3、根据各节点记录的偏移量，偏移量最大的成为master；
    
     4、前边都相同，进程id最小的成为master；



### 对Redis Rehash的理解

 dictht有两个，dictht[0]、dictht[1]

 dictht[0]会存储数据，dictht[1]开始不会创建；扩容因子默认5，dictEntry采用链式地址法进行存储，当hash碰撞时，在同一位置进行链式存储；当碰撞过多，链式地址存储数据过多，hash查找的优势也就不复存在；

 1、当发生rehash时，dictht[1]进行创建，大小为dictht[0]的2倍的2的N次方；

 2、dictht[0]的数据进行重新hash运算，获取新的位置信息，存放到dictht[1]中；

 3、数据迁移完成后，清除dictht[0]，然后把dictht[1]改为dictht[0]，再创建一个dictht[1]，用于下次rehash；



## 实战

### Redis内存在什么情况下会满？

内存里面的数据超过指定的最大内存。例如：key没有指定过期时间但一直在往里面新增key。或者有过期时间！但是短时间加的速度很快也会导致内存占满。



# Spring Cache

### SpringCache的作用是？

Spring Cache 是 Spring 框架中用于缓存的模块。它提供了一个声明式的缓存抽象，允许开发人员使用注解或 XML 配置轻松地将缓存集成到他们的应用程序中。

Spring Cache 可以与多种缓存实现集成，如 Ehcache、Caffeine 和 Redis

Spring Cache 支持二级缓存，允许开发人员将数据缓存在多个层中，以提高性能和可伸缩性



### 和Redission相比他的优缺点

**优点：**

- 易于使用：Spring Cache 提供了一个声明式的缓存抽象，允许开发人员使用注解或 XML 配置轻松地将缓存集成到他们的应用程序中。
- 与多种缓存实现集成：Spring Cache 可以与多种缓存实现集成，如 Ehcache、Caffeine 和 Redis。
- 支持二级缓存：Spring Cache 支持二级缓存，允许开发人员将数据缓存在多个层中，以提高性能和可伸缩性。

**缺点：**

- 缺乏分布式锁：Spring Cache 本身不提供分布式锁功能。
- 缺乏事务支持：Spring Cache 不支持事务。
- 缺乏事件监听：Spring Cache 不提供事件监听功能。
- 配置更复杂：使用 Spring Cache 直接连接 Redis 需要更复杂的配置。
- 性能可能较低：使用 Spring Cache 直接连接 Redis 可能比使用 Redisson 性能较低。





# Memcached



# Caffeine

### Caffeine的优缺点

Caffeine 是一个开源的、高性能的 Java 缓存库，由 Google 开发和维护。它提供了一个简单的 API，用于创建和管理缓存，并具有以下特点：

**优点**

- **高性能：**Caffeine 是一个非常高效的缓存库，可以处理高吞吐量和低延迟的请求。
- **可扩展性：**Caffeine 可以轻松扩展到处理大量数据和并发请求。
- **可定制性：**Caffeine 提供了丰富的配置选项，允许用户根据自己的需求定制缓存行为。
- **易用性：**Caffeine 提供了一个简单的 API，使创建和管理缓存变得容易。
- **社区支持：**Caffeine 有一个活跃的社区，提供支持和帮助。

**缺点**

- **不支持分布式缓存：**Caffeine 不支持分布式缓存，因此不适用于需要跨多个服务器共享缓存的场景。
- **缺乏高级特性：**Caffeine 缺乏一些高级特性，如持久化和事件通知。
- **文档有限：**Caffeine 的文档相对有限，这可能会给初学者带来一些困难。

**使用场景**

Caffeine 适用于各种需要缓存的场景，包括：

- **数据库：**缓存经常查询的数据，以减少数据库负载。
- **分布式系统：**缓存远程服务或微服务的响应，以提高性能。
- **机器学习：**缓存训练好的模型或中间结果，以加快推理过程。

总体而言，Caffeine 是一个功能强大且易于使用的 Java 缓存库，适用于各种需要缓存的场景。它的高性能、可扩展性和可定制性使其成为要求苛刻的应用程序的理想选择。



# EhCache

### EhCache优缺点

EhCache 是一个开源的 Java 分布式缓存，由 Terracotta 开发和维护。它提供了一个简单易用的 API，用于创建和管理缓存，并具有以下特点：

- **高性能：**EhCache 旨在提供高吞吐量和低延迟的缓存操作。
- **可扩展性：**EhCache 可以轻松扩展到处理大量数据和并发请求。
- **分布式：**EhCache 支持分布式缓存，允许在多个服务器之间共享缓存数据。

**优点**

- **高性能：**EhCache 是一个非常高效的缓存，可以处理高吞吐量和低延迟的请求。
- **可扩展性：**EhCache 可以轻松扩展到处理大量数据和并发请求。
- **分布式：**EhCache 支持分布式缓存，允许在多个服务器之间共享缓存数据。
- **易用性：**EhCache 提供了一个简单的 API，使创建和管理缓存变得容易。
- **社区支持：**EhCache 有一个活跃的社区，提供支持和帮助。

**缺点**

- **商业许可：**EhCache 的企业版需要商业许可，这可能会给一些用户带来成本问题。
- **复杂性：**EhCache 的分布式特性可能会给配置和管理带来一些复杂性。
- **文档有限：**EhCache 的文档相对有限，这可能会给初学者带来一些困难。

总体而言，EhCache 是一个功能强大且易于使用的 Java 分布式缓存，适用于需要高性能、可扩展性和分布式缓存的场景。它的企业版提供了额外的特性和支持，但需要商业许可。

