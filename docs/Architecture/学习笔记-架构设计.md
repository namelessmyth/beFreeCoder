# 系统架构设计

## 架构设计原则

### 好系统是迭代出来的

在我们的技术生涯中，总是不断针对新的需求，去研发各种不同的系统，而不同的系统的设计是可以触类旁通的。在设计系统时，要根据项目背景、项目工期、不同的场景，做不同的设计。

项目背景举例，例如：做电商的项目和做金融的项目，侧重点就不一样，金融侧重精确性，电商侧重高并发。

一个系统并不是一下子就能设计的特别完美，我们都知道系统实施的过程中，一定是先解决当下最核心的问题，预测并发现未来可能会出现的问题，一步一步解决最头疼的问题。

例如：项目上线时的预估用户量就1000，那单机架构也是可以支撑的。同时可以预留未来升级的可能性。

也就是说系统设计其实是一个不断迭代的过程，在迭代中发现问题并修复问题。即满足需求的系统是不断迭代优化出来的，这是一个持续的过程，包括国内BAT巨头的系统，也是经过了这个历程。淘宝也是从单机开始的。

话又说回来，如果一开始我们就站在了巨人的肩膀上，在前人的经验上，有一个好的系统基础架构设计，未来就更容易达到一个比较满意的目标。

一个好的系统架构设计要做到，解决现有的需求，完成现有的目标，把控进度和风险，预测和规划未来，但是也不要过度设计，让系统在迭代中演进和完善。

在工作中，我们作为一个架构师，要鼓励团队成员积极主动沟通，并推动系统演进，另外也要思考二八定律，将有限的资源，用到更有价值的需求上，以最小化可行产品的方式迭代推进。

**总结** ：

- 好的系统都是迭代出来的。
- 先解决核心问题。
- 不要过度复杂化系统设计。
- 先行规划和设计是有必要的。
- 对现有问题有方案，对未来系统发展有预案。



### 无状态原则

#### 什么是无状态

无状态服务（Stateless service）是指：对单次请求的处理，不依赖于其他请求。

也就是说，处理一次请求所需的全部信息，要么都包含在这个请求里，要么可以从外部获取到（例如：配置文件，数据库，Redis），服务器本身不存储任何信息 ，也就是说：服务器是不保存请求的状态的，这就是无状态。

**反例**：处理这一次请求时还要去判断上一次请求。第2个请求依赖于第一个请求。这就是有状态的设计。

**案例**：每次请求都需要先鉴权，这算不算有状态？

例如：首先得先调用用户登录接口，登录成功有了token才能调用创建订单接口。

区分是否无状态，主要还是看服务器本地有没有存储token，如果没存那就是无状态的。如果存了，那就是有状态的。

#### 无状态原则的好处

由于服务器不保存任何信息，那么应用就能进行水平扩展。反过来，如果服务器存了请求的状态信息，那另一台服务器会因为就读取不到造成业务错误。

在实际生产环境中，一般是这样的：应用无状态，配置文件有状态。比如不同机房的服务，需要读取不同的数据源，那么这时候，就需要通过配置文件或配置中心来指定不同数据源的配置。



### 拆分原则

要做成一个什么样的系统？是大而全还是按照一定规则进行拆分的小系统？这个需要根据背景来权衡。

例如：做一个系统，用户量不大，就公司内部几百个人在使用，功能也很简单，并且开发者也就一个人，这时候就没必要进行系统拆分。

而如果是做一个类似于淘宝的秒杀系统，公司投入的资源很充足、业务功能复杂、用户量也特别大，那我们就需要进行系统拆分了。

总结拆分原则：高内聚、低耦合。

拆分前提：要对系统当前的状态有一个清晰的认识。基于一些重要信息去考虑拆分。可以考虑使用各种方式去埋点。例如：日志分析。可以在每个方法进入和退出时加入日志。或者安装监控系统。

**拆分维度**

#### **系统维度**

比如拆分成：商品系统、购物车系统、支付系统、优惠券系统等等。这一点需要和产品经理配合。

例如：拆分出支付系统后，这个系统可以给很多其他系统使用，其他公司都可以调用。

例如：用户系统，每次用户系统有改动，都要连带商品系统，订单系统一起发布，风险较大，维护较麻烦。

#### **功能维度**

在系统维度进行拆分后，再对一个系统进行拆分：比如优惠券系统，可以拆分成后台券创建系统、用户领券系统、用券系统等。

#### **读写维度**

首先要基于读写分析数据，根据读写比例特征进行拆分。比如有一些功能，都会进行大量的读写数据，然而读写比例失衡，比如说：读的量远远大于写，因此可以拆分成商品写服务、商品读服务。读服务就可以考虑使用缓存，来提升性能。如果某个服务写的量特别大时，需要考虑表分区、分库分表等等。

数据库的读写分离也可以看到读写分离的一种情况。

#### **切面维度**

比如一些大型的网站，全国各地的用户特别多，都来访问商品详情页，这样就可以分为cdn、页面渲染系统；cdn就是一个aop系统，类比于面向切面。在用户和实际服务中间拦一道。

CDN优化一般针对静态资源，对数据实时性要求不高。所以一般不用考虑数据库的分布式。

#### **模块维度**

根据公共基础模块或代码维护特征进行拆分，比如数据连接池模块、分库分表模块，综合消息队列。代码一般都是三层（，controller，service，dao。web service dao）。

一些大厂的会有基础架构组，专门给其他开发组提供二方库。例如：阿里，很多小公司现在用的开源框架，druid，rocketMQ就是这个组开发的单独模块。这些库在阿里内部项目使用时就在二方库，在其他公司使用就是三方库。



### 服务化原则

我们在开发项目的过程中，首先判断是不是单节点就能实现？

然后判断是不是简单的远程调用单个节点服务就可以实现？如果单个节点满足不了要求，那么节点集群是不是就可以？集群是不是用nginx做负载均衡就能满足？如果调用方越来越多，是否考虑，使用服务的自动发现 和 注册功能。

当服务越来越多的时候，服务越来越不好管理的时候，还需要考虑服务隔离，防止有的服务访问量大，把整个系统拖垮。那么继续发展，流量越来越大，我们还有进行限流，黑白名单，由于网络的不稳定，我们还需要超时重试故障补偿等功能，这些都会影响服务的质量。还有：熔断，限流，降级等。

总结：单个服务完成功能，调用单机远程服务，调用集群服务手动注册服务  自动发现注册服务  服务治理。



## 业务设计原则

本章节主要讨论的是每个业务功能基本都会涉及的设计原则。

### 防重原则

这里的防重指的是，防止重复提交。当请求响应时间变长，用户可能会多次点击同一个请求。

防重方法：不仅仅是前端要做防重处理，更重要的是后端。前端的防重有很多方式可以绕开。例如：新开一个浏览器页面，使用debug模式，通过api工具直接调用后台方法。

防重主要针对的是写操作，读不需要考虑防重。写操作也有些场景是不需要做防重控制的。例如：逻辑删除（数据库中根据某条数据的id将删除字段改成1）

首先系统必须能正确识别重复请求。例如：根据业务id判断，token判断等等。

针对重复请求做拒绝处理。



### 模块复用原则

当我们开发功能的时候，有复制粘贴欲望的时候，就应该思考一下，这个功能是否能复用。

总结起来，模块复用就是沉淀通用功能。例如：字典项功能，系统配置项功能，通知功能，定时任务功能，通用搜索功能。现在的很多低代码平台也是模块复用原则的一种体现。使用低代码平台时，只要涉及好业务对象，增删改查功能不用开发，通过配置就能使用。



### 可追溯原则

任何问题，要有据可查。这种有据可查不仅仅是写日志。有的系统还有历史记录功能，用户自己看历史记录都可以判断出来是不是自己操作问题。



### 反馈原则

系统的每个功能，但功能使用出现错误时，最好提供清晰明白的反馈信息。让用户一看就知道是自己哪里错了，怎么才能操作正确。

例如：用户名不存在，账号密码错误，用户无权限等等。

良好的反馈能很好地减少沟通成本，减轻开发人员沟通时间。



### 备份原则

备份主要是为了灾难恢复，让损失降低的到最小。

**代码备份**

Git，分支。备份所有发布版本，出现问题还能重新打包，部署。

**数据备份**

数据库的数据，可以使用运维备份（例如：数据库备份），操作记录也要注意备份（例如：日志，变更历史等等）。

**人员备份**

人员备份主要是为了不要因为某个人离职，对项目进度产生很大影响。

进行合理的代码review也是一种人员备份。避免出现某个开发思路很诡异或者随意使用团队没人会的第三方框架，导致新招来的交接人员可能会直接离职。

对于代码的低级问题对生产环境造成影响的。要对编写人，审核人，测试进行追责。

同时还可以采取**入库前代码review**。提交之后代码必须某个人审核通过才能入库。这样即使某个人离职了，审核人对他写的代码也熟悉。代码review工具推荐：[gerrit](https://zhuanlan.zhihu.com/p/21482554)。

在华为有这样一个挑刺制度，就是A写完代码，B来挑刺。B挑的刺越多绩效越高。还有一个制度叫做摇人，当你遇到功能不知道怎么开发时，可以通过摇人找人帮忙教你做。



## 软件质量衡量标准

衡量软件质量主要是为了从不同的维度，对某个人负责的项目进行评判。评判结果涉及相关人员的绩效，晋升。

既然要衡量，就涉及衡量标准。

### 功能

符合功能要求。

### 效能

投入多少，产出多少。

投入指的是投入多少时间，投入多少资源（人力，硬件资源），容量（数据库大小，网络带宽，事务吞吐量）

产出指的是系统能抗住多少并发，承载多少用户。

### 兼容性

软件的适应性有多广，是不是调用了一下第三方就崩溃了，或者多一个调用方就崩溃了。

### 易用性

在指定的条件下，能够很容易得让用户达到业务目的。

### 可靠性

容错，可恢复。多长时间可恢复。

### 安全性

用户输入一个非法字符系统就崩了。

### 可维护性

代码易读。功能设计符合公司规范，即使换个人来维护，也能轻易上手。

有的人可能会觉得软件可维护性越高，别人来能轻易上手，自己的可替换性就大就会显得自己不重要。

软件做得好，首先自己有成就感。然后别人看到了觉得你很牛。领导看到升职加薪机会更大，同事看到将来推荐你的机会更大。

### 可移植性

系统在一个地方用的很好，换一个地方也能用。



## 系统衡量指标

### 吞吐量

吞吐量是指单位时间内软件系统能接收和发出的数据量，主要体现系统处理请求的能力，这也是目前最常用的性能测试指标。

#### TPS

Transactions Per Second，每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。

QPS（每秒查询数）、TPS（）是吞吐量的常用量化指标，另外还有HPS（每秒HTTP请求数）。



#### QPS

Queries Per Second，每秒查询数。QPS主要针对查询服务性能指标，服务后面接的数据库中SQL的每秒执行条数。如果描述的是前端的每秒查询数，那就不包括插入、更新、删除操作了。不建议用QPS描述系统整体性能。



#### TPS&QPS

例如：将刷新淘宝页面当成一次事务，那这次事务中会有很多个查询（图片，商品信息）。具体要看事务是怎么定义的。

还有就是这里的事务和查询不要和数据库里的概念混淆起来，讨论QPS和TPS时并不和具体的底层实现强关联。而是在用户或者测试角度上的一件事和一次查询。

QPS和TPS并不能精确说明系统的性能高低，但可以用于衡量，程序或者配置修改后，系统的前后变化。



#### HPS

Hits Per Second，每秒HTTP请求数。Hit在性能测试中，一般都用来描述 HTTP Request。但是，也有一些人用它描述真正的客户在界面上的点击次数。



### 并发数

关于并发数有很多概念，例如：并发用户数，并发连接数，并发请求数，并发线程数。

#### 并发用户数

即：单位时间内同时使用系统功能的用户数。

有两种常见的错误观点。一种错误观点是把并发用户数量理解为使用系统的全部用户的数量，理由是这些用户可能同时使用系统；还有一种比较接近正确的观点是把用户在线数量理解为并发用户数量。实际上，在线用户不一定会和其他用户发生并发，例如正在浏览网页的用户，对服务器是没有任何影响的。但是，用户在线数量是统计并发用户数量的主要依据之一。

并发主要是针对服务器而言，是否并发的关键是看用户操作是否对服务器产生了影响。因此，并发用户数量的正确理解为：在同一时刻与服务器进行了交互的在线用户数量。

#### 并发连接数

并发连接数指的是客户端向服务器发起请求，并建立了TCP连接。每秒钟服务器链接的总TCP数量，就是并发连接数。

有了并发连接，用户不一定会进行操作，仅仅维持连接对系统性能影响还是比较小的。

#### 并发请求数

和TPS类似，指的是单位时间内对服务器发起请求的数量。

#### 并发线程数



### 响应时间

#### RT

Response Time，响应时间，简单理解为系统从输入到输出的时间间隔，宽泛的来说，他代表从客户端发起请求到服务端接受到请求并响应所有数据的时间差。一般取平均响应时间。 

[阿姆达尔定理](https://www.zhihu.com/tardis/zm/art/48022905?source_id=1005)：Gene Amdahl进行了一个富有洞察力的观察： 提升一个系统的一个部分的性能对整个系统有多大影响。这一观察被称为Amdahl's Law（阿姆达尔定律）

简单来说就是优化系统时应该第一考虑响应时间最长的那个。



### 可靠性指标

如果一个大系统有5个串联子系统构成，且每个子系统的可靠性都是99%，则系统整体的可靠性为5个99%相乘约等于95%。所以串联系统越多可靠性越低。

那如果改成并联，则是`1-(1-99%)*(1-99%)*(1-99%)*(1-99%)`，可以得出并联的情况下子系统越多越可靠。

并联的意思是一个系统的冗余从节点（集群）。A系统调用B系统时，B存在多个子节点，即使主节点挂了从节点会自动选举出新的主节点，系统依然可用。

这也是为什么可靠性要求越高，越要消除单点，化串联为并联。

生活案例：你出去买东西，一手交钱一手交货。你从网上买东西时，你先付钱，一段时间后才会给你发货，这就把交钱和交货分开了，它能不能发货不影响你付账。付钱的方式可以有多种：支付，微信，银行。发货的公司也可以有多家。但如果全中国只有一家送货公司，你可能就会担心付了钱可能会收不到货，选择一手交钱一手交货的方式了。



# 客户端优化

假设我们的系统，现在有1亿的用户手机端。那要如何优化才能使服务端支撑的了如此大的请求数？

首先，我们可以先考虑优化客户端，有一些处理可以尽可能的在这一亿的用户手机端完成

例如：app启动时，可以先从后端请求一些规则类的文件，然后存储在客户端。

然后后续需要做计算时，可以直接使用这些缓存的数据。例如：预估价格的场景，前提是允许预估价和实际价格不一致。

客户端分类：Android，iOS，浏览器。对于后端来说都是调用接口而已。只是资源的获取，处理，展示方式可能不同。

## 资源下载

资源：样式文件，脚本文件，图片，视频，文本等等。

**减少不必要的数据传输**。例如：不必要的cookie。cookie中的数据会和请求一起传给服务器。1个cookie可能1kb，那1亿个呢？某国民级应用有8亿用户。

案例：百度一开始接春晚时，前端要调用后端100个接口，后面优化至8个接口。春晚当天晚上可能有几亿用户使用，节约1kb也是一种很大的优化。

**压缩**。将资源压缩之后可以有效提供资源下载速率。客户端上传数据给服务器时也可以考虑压缩。

案例2：在用户上传图片时，除了存用户上传的原图，可以[自动生成图片的缩略图](https://blog.csdn.net/administratop/article/details/121553828)。当用户浏览图片时，可以先展示缩略图，用户进一步操作之后再展示原图。这也是一种压缩方式。淘宝的商品详情页，只有当鼠标放到图片上才会显示高清图。

JavaScript：删除无效字符，注释，1。减少体积，2。代码安全（让别人看不懂）。语义合并。

CSS：类似。语义合并。9行。原来10个按钮 10个样式，class 1个样式。

**http请求压缩**：

head中加参数：Accept-Encoding：gzip，deflate

表示客户端可以接受的压缩内容的格式。此时如果服务器支持压缩的话就会将响应内容压缩之后传给客户端

同时服务端响应中会加入：head: Content-Encoding:gzip。浏览器识别到这个响应后，就会利用自带的解压缩机制解压。

所以在服务端做一些压缩的操作。可以有效介绍数据量。

**减少请求次数**

客户端和服务器之间的连接需要经历3次握手，4次挥手。对于资源数目多、体积小，频繁创建http链接就消耗较大。

案例：如果一张雪碧图中包含了很多小图片，那可以将这些小图片合并成一张大图，通过样式文件background-postition来定位显示。

例如：矢量图可以通过记录坐标，然后通过：`<svg >`标签画出来。

js合并。将多个js文件打包成一个，一次下载。

使用base64图片也可以减少图片体积。在通过gzip压缩。

gzip 对文本文件的压缩  能压缩到原来的 40%以下。

将流量转移给第三方。OSS，图片，静态文件直接请求阿里云。



## 连接优化

### 长短连接

http1.0 不支持长连接，http1.1 默认长连接，

其实http根本没长短连接一说，连接是针对的tcp，所以上面的说法是错的。

http是针对请求和响应模式的，只要服务端给了响应，本次http连接结束。

TCP是一个双向的通道，他可以保持一段时间的不关闭，所以他才有长短连接。

http1.1在发请求的时候，如果在请求头中默认包含这个参数，connection:keep-alive。后端给前端返回的时候也带这个参数，那就能复用这个tcp的长连接。

测试：使用postman调用www.baidu.com，你会发现在headers中默认就会带上这个参数。

好处：减少了创建和销毁连接的消耗。

案例：请求一个网页（baidu.com），网页中包含css、js、html，如果每次都要建立新的连接。那这些资源也会每次重新下载

长连接并不会一直不关闭，只要超过header里设置的超时时间没有发送接收数据，就会自动关闭。

在chrome中按F12，然后点Network，观察后台的请求，如果这个是一个长连接，那每次刷新连接id是不会变化的。



### 长短轮询

例如：仓库库存字段，这个字段需要确保他在界面上始终显示最新的（即使用户没刷新页面）有哪几种实现方式。

写个js方法，不断的调用后台？去查询后台的库存是多少。这种方式能实现需求但是浪费了服务器的资源。这种时候就可以使用长轮询。

长轮询：客户端请求服务端，服务端如果发现数据没有变化，则将当前请求挂起一段时间。一直等到超时，如果有变化，才返回。这种方式大大减少了服务端和客户端的数据交互次数。降低了服务端一直疲于接收客户端请求的情况。

假如是查询数据库的，那不是一直要不停的查询吗？

1。 用redis。

2。发布 订阅。

形成自己的解决问题的 思路的框架。

双工通信

netty，websocket（ws）。

http在tcp的基础上 有 长 短  轮询。

tcp链接 有 长短。

现在 基本上都是http1。1 默认支持长连接。

长轮询 ：是服务端控制的。

双工通信：前后端 可以彼此 交互。

connection: keep-alive

keep-alive: timeout=60s



## 资源的缓存

页面缓存，客户端本地缓存（）

页面的缓存：可以控制  客户端、各级代理（中间的各个节点）、 对页面资源的缓存。

如何控制：headers :     Cache-Control:public

可缓存性：

pubic（服务器 响应中）: 各级都能缓存。

private（服务器 响应中）: 只能 客户端 缓存，中间各级不缓存。

no-cache: (请求，响应)：可以缓存，但是不能直接使用缓存，要去服务端验证一下。

no-store: (请求，响应)：哪都不要存。

缓存有效期：

max-age=秒，缓存可以存活的时间。

s-maxage=秒，在各级节点存活的时间，如果是 客户端存储忽略。

max-stale=秒，可以忍受资源过期的时间。

min-fresh=秒，

重新验证和加载的设置

must-revalidate: 服务器重新验证之前，不可以使用该资源。

proxy-revalidate: 各级节点有效。

no-transform: 不能压缩图像。

only-if-cached: 只要缓存的，不要服务器的资源。

header：

Cache-Control: pulic, max-age=10,no-transform

缓存更新不及时：

1。更新文件名：版本号，url时间戳的变化。my-js.js。my-js-1.js。客户端和服务器要达成一致。

**发布上线一个文件，这个文件名是变的，那么 缓存的文件 就失效了。**

2。验证 缓存的有效性。

基于 文件的最后修改时间。

服务端：last-modified :  最后修改时间。

客户端：if-modified-since ：自己需要资源的时间。

你要我1个手机，我给你手机，手机贴标：时间戳。。304，不返回具体资源。200：返回具体资源。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/30/1642337988000/87aa337ded1f41738bf3fc5587347faa.png)

基于：版本号的。

etag: 版本号。

客户端在请求中：if-none-match:

## 2。 解析。元素，样式，脚本。

目的?  优化解析。

1。优化正常解析流程。

元素

css样式文件        render tree  布局好，  绘制。

js脚本

回流：

重绘：

目的：缩小 回流和重绘的 范围。

方法：分几个块。

2。创新解析流程。：

虚拟dom（Virtual  DOM）。算法，比较前后两个dom的区别。

**如果改变不了 它 本来的面目，那么就给 它 化化妆，改变展现的面目。**

oracle 物化视图？

缓存 redis？

---

## 懒加载

h5  app 界面。

懒加载：仅仅加载 最基础的元素，以后，再根据用户的操作，进行局部加载。将原来一次性要加载的内容拆分成了多次加载。分流。

回流、重绘。

app上的，

树形组件，折叠面板，标签页。

尽量灵活一些，支持多种情况。

到了不得不看具体数据的时候，才调用后端。

但是也不一定，一些 经常不变的数据，就没必要了。

## 预加载

先后顺序。

1 2 3 4 5 ---10

1。同一个域名下。

拉去资源

`<link rel="preload" href="xxxx.js" />`

`<link rel="prefetch" href="xxxx.js" />`

2。不同域名下。

A，B，C

减少域名解析此时：dns缓存。

DNS预获取。

dns解析速度，被很多人忽视。蚊子腿也是肉。

预解析：

dns解析，多级递归查询。对时间是消耗，我们想办法节省时间。

我们在当前页面，完成对下一个页面域名的解析，而在下一个页面直接使用预解析之后的结果。

dns prefetching。

告知浏览器 打开域名的预解析

`<meta http-equiv="x-dns-prefetch-control" content="on">`

解析谁

`<link rel="dns-prefetch" href="//www.baidu.com">`

`<meta http-equiv="x-dns-prefetch-control" content="off">`

拉去资源

`<link rel="preload" href="xxxx.png" />`

`<link rel="prefetch" href="xxxx.js" />`

`preload`: 针对当前页面，更早的去下载资源，当前页面的资源。

音频，视频，embed，图片，js，css，

prefetch: 针对下一页，如果下个页面 存在比较大的资源，当前页面处理完，浏览器闲置的时候，

会去加载 该资源。

扩展：

图片->base64->放到 css文件里。

## 客户端数据库

一个用户1k，1000w个用户   10G。

cookie算一个：过期时间，坏处：

sqllite。

## 动静分离

媒体类网站：一篇新闻，

数据不仅包括 传统意义上的页面，也包括 没有和访问者相关的个性化数据。

缓存：

把静态数据 放到 离用户最近的地方。：浏览器，cdn，服务端的cache。

链接和数据做映射。url1 获得一个数据。key value。如果缓存到了 客户端，都不用发http请求了。

nginx,apache。

怎么做？

url唯一，做映射。

特殊展示的元素做分离：尽可能的多做静态化。

将页面中的cookie，与用户个性化相关的 东西  去掉。

架构方案：

静态服务器：nginx,apache

统一缓存管理服务：缓存做分发。

上CDN得了。

数据库查的 数据  +   样式文件   =  html文件。

**客户端优化 到此为止**

用户在客户端中的优化。



# 职业规划

## 架构师

### 什么是架构师？

对于一个公司而言，架构师引领着整个公司的技术方向，架构师的眼界和高度决定了一个公司的技术高度。

对一个技术团队而言，架构师的决策和技术方案，影响着工程师的开发模式和开发工作量。

一个好的架构师能让团队用最少的工作达到最好的效果。就是事半功倍。一个差的架构师可能就是事倍功半。

一个好的架构师是一个公司的宝贵财富，一个差的架构师是一个团队的噩梦。



### 架构师分类

首先架构师并没有全球统一的分类标准。不同公司，不同国家对架构师的分类可能都是不一样的。

#### 按照职责分

架构师分为：产品架构师，开发架构师，运维架构师。



**产品架构师**

负责整个产品的技术架构，当产品的业务规划和规则确定后，产品架构师需要开始设计产品，确定产品模块之间的架构，

和运维团队确定用户数，PV数（PageView，网页访问量）商品数，订单量等等非功能性的运维指标。

和产品经理确定功能需求，功能模块的划分。

和项目经理确认开发资源，测试资源。每种资源能安排多少人到项目上。

收集到所有相关信息后进行整体的架构设计。然后给销售，运营，开发，测试，运维确定目标。

还需要参与到产品的整个生命周期中去。从无到有到最后上线，版本升级。

这种架构师比较高端。



**开发架构师**

1. 负责开发基础框架，公共组件，通用服务等等可以让很多人使用的功能。
2. 对于开发成果需要承担海量数据存储，高性能，高并发，高可用等三高问题。
3. 负责核心功能开发。项目组疑难问题解决。以及其他具有技术挑战性的工作。



**运维架构师**

负责网络存储等运维工作，例如：负载均衡，多个数据库，多个存储，多个消息队列，多个日志如何归类如何存储等等。



#### 按照工作分

架构师分为：普通架构师，极客型架构师，助人型架构师，扫地僧架构师，布道型架构师。

**普通架构师**

负责系统架构设计，框架的实施落地，后期技术演化重构，核心代码编写等

**极客型架构师**

满足普通架构师的要求，对于某些技术领域有特别深入的研究，达到精通的程度。例如：阿里P7

**助人型架构师**

当团队成员遇到困难时，需要给予一定的帮助，帮助其他成员快速成长。

**扫地僧架构师**

每当系统出现故障，一般人搞不定时都需要他们出马。他们可能是随着公司的开发发展到壮大一直都在，所以他们对公司的整体技术架构非常清楚，所以他们是公司的定海神针。

**布道型架构师**

存在较好的个人影响力，以及坚定的技术信仰，乐于分享，在公司内部能推动推广自己的技术主张。这种类型的架构师也反面教材，也有一部分放弃学习，停止成长，出于自身的局限最终成为一个忽悠型架构师，阻碍公司发展的。



#### 关注点

### 功能



### 非功能



### 团队与组织管理



### 产品运营



### 产品未来



## 进大厂

### 大厂介绍

一线大厂：bat，字节，美团，华为，微软

二线大厂：京东(836)、网易(680)、拼多多(610)、百度(480)、快手(380)、携程(250)、贝壳(150)、滴滴(100)



### 面试内容

#### 算法

美国的大厂对于应届生基本主要考察这个。这个是程序员的基本功，相当于易筋经，不是短期突击就能突击出来的。



#### 架构设计

这是另一个国外大厂考核有经验程序猿的主要内容。也是需要长期积累的。

同样是设计一辆车，张三设计出来的可能是奥拓，李四设计出来的可能是奔驰。虽然功能类似都是设计理念，未来扩展，质量并不相同。

会通过一些实际的案例，要求面试者进行架构设计来达到业务要求。知识包括：设计模式，框架源码，技术选型等。

例如：设计架构支持春节红包雨，30秒内抢1亿的红包。红包数量：1000万，用户数：3000万。每个用户只能抢成功1次。



#### 面试八股

包含面试的常见内容，不同的厂可能问的内容不一定一样。但是这部分知识积累的越多越好。

例如：JVM，并发优化，Redis，MQ，设计模式，Spring源码



#### 项目应用

主要是看简历中项目经验中对于考察知识的实际应用。前面答得好



#### 加分项

这部分内容有的话加分，没有影响也不大。例如：云原生，大数据，AI。



## 大龄问题

