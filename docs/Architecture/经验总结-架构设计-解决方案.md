# 架构设计-解决方案

# 文档说明

本文档主要用于记录所有已知的业务功能的解决方案。同一个业务的解决方案往往不止一种，所以还会列出每一种解决方案的优缺点和适用场景。

**符号说明**：✅代表已发布；🙌代表整理中；↗️代表转载的他人作品

| 文档名称     | 架构设计-解决方案 |
| ------------ | ----------------- |
| 文档分类     | 经验总结-架构设计 |
| 版本号       | 1.0               |
| 最后更新日期 | 2023-12-24        |
| 最后更新人   | Gem Shen          |
| 编制日期     | 2024-02-03        |
| 编制人       | Gem Shen          |



## 文档更新记录

| 版本 | 编制/修改人 | 修改日期   | 备注（原因、进一步的说明等）               |
| --- | --------- | -------- | --------------------------------------- |
| 1.0  | Gem | 2021-02-03 | 初版，使用[ProcessOn思维导图](https://www.processon.com/view/link/608e670f5653bb720e1ffee2)记录 |
| 1.1  | Gem | 2024-02-03 | 开始用文档记录，脑图不适合记录细节和搜索。|



# 文件处理

## PDF处理





## 在线预览

kkFileView



## 在线编辑

### OnlyOffice

[官网文档](https://www.onlyoffice.com/zh/download-docs.aspx#docs-community)，

缺点：不开源，社区版最大连接数限制20



## 文字识别

### PaddleOcr

[GitHub](https://github.com/PaddlePaddle/PaddleOCR)，[Gitee](https://gitee.com/paddlepaddle/PaddleOCR)。目前主流的OCR库，在国内专业领域认可度相当的⾼。可以识别近80种语⾔，并且识别准确度和速度都非常⾼。

缺点是基于Python，对于没接触过Python的人来说有额外学习成本。



### Tess4J

Tess4J可以和Spring Boot做集成来实现OCR（光学字符识别），以识别出本地和远程图片中的文字。[↗️原文链接](https://mp.weixin.qq.com/s/dWNrGc3MFispISC_3IB7iA)



# 消息通知

## 短信

如阿里云短信服务、腾讯云短信服务、



## 电子邮件

SendGrid邮件服务



## 企业微信



## 微信



# 规则引擎

### liteflow

**使用场景**

[官网](https://liteflow.cc/pages/5816c5/#%E5%89%8D%E8%A8%80)

在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统RPC调用等等。时间一长，项目几经易手，维护成本就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。

如何打破僵局？LiteFlow为解耦逻辑而生，为编排而生，在使用LiteFlow之后，你会发现打造一个低耦合，灵活的系统会变得易如反掌！

优势

如果你要对复杂业务逻辑进行新写或者重构，用LiteFlow最合适不过。它是一个编排式的规则引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件。

利用LiteFlow，可以将瀑布流式的代码，转变成以组件为核心概念的代码结构，这种结构的好处是可以任意编排，组件与组件之间是解耦的，组件可以用脚本来定义，组件之间的流转全靠规则来驱动。LiteFlow拥有开源规则引擎最为简单的DSL语法。十分钟就可上手。



# 安全

## 认证授权

认证和授权的区别在于认证是验证用户身份的过程，而授权是确定用户被允许执行的操作或访问的资源的过程。

下面将介绍认证授权相关的框架与协议



### OAuth 2.0

**简介**

OAuth 2.0是一种认证授权框架，用于授权第三方应用访问用户资源，而无需提供用户的凭证。它允许用户授权第三方应用代表用户进行访问，同时保护用户的凭证不被第三方应用获取。

**适用场景**

适用于Web应用、移动应用和API访问控制等场景。

**应用场景**

OAuth 2.0广泛应用于各种场景，以下是一些常见的应用场景：

- **社交登录**：用户可以使用他们的社交媒体帐户登录到其他应用程序，例如使用Google或Facebook登录。
- **API访问**：开发人员可以使用OAuth 2.0来访问第三方API，例如使用GitHub API或Twitter API。
- **单点登录**：用户可以使用一个身份验证提供商登录到多个相关的应用程序，而无需多次输入凭证。
- **授权访问**：应用程序可以请求用户授权访问其资源，例如Google云存储或Dropbox。
- **移动应用授权**：移动应用程序可以安全地请求访问用户数据，如照片、联系人或位置信息。



### OpenID Connect

**简介**

OpenID Connect（OIDC）是建立在OAuth 2.0之上的身份验证协议，它扩展了OAuth 2.0，提供了对用户身份验证的支持。OpenID Connect使用OAuth 2.0的授权流程来获取访问令牌，并在此基础上添加了身份令牌（id token）来验证用户的身份。因此，OpenID Connect不仅提供了授权，还提供了对用户身份的验证和认证。

**适用场景**

适用于需要进行用户身份验证，并获取用户身份信息的场景，如单点登录、用户认证等。



#### JWT

JWT（JSON Web Token）是一种用于在网络间安全传输声明的开放标准（RFC 7519），它通常用于在OAuth 2.0和OpenID Connect中传递访问令牌和身份令牌。JWT是一种紧凑且自包含的方式来表示信息，它使用数字签名或加密来验证其完整性和真实性。[在线演示](https://jwt.io/)。

##### Hutool JwtUtil

Maven依赖

```xml
<dependency>
    <groupId>cn.hutool</groupId>
    <artifactId>hutool-all</artifactId>
    <version>5.8.21</version>
</dependency>
```

参考代码

```java
package com.gem.common.jwt;

import cn.hutool.core.date.DateField;
import cn.hutool.core.date.DateTime;
import cn.hutool.json.JSONObject;
import cn.hutool.jwt.JWT;
import cn.hutool.jwt.JWTPayload;
import cn.hutool.jwt.JWTUtil;
import lombok.extern.slf4j.Slf4j;

import java.util.Map;

@Slf4j
public class JwtUtil {
    /**
     * 盐，很重要，不能泄漏，建议放到配置文件中
     */
    private static final String SALT = "salt-test-123456";

    public static String createToken(Map<String, Object> data) {
        DateTime now = DateTime.now();
        DateTime expTime = now.offsetNew(DateField.HOUR, 12);
        // 生效时间。
        data.put(JWTPayload.ISSUED_AT, now);
        // 失效时间。
        data.put(JWTPayload.EXPIRES_AT, expTime);
        String token = JWTUtil.createToken(data, SALT.getBytes());
        log.info("token创建：{}", token);
        return token;
    }

    /**
     * 校验token是否有效
     */
    public static boolean checkToken(String token) {	
        JWT jwt = JWTUtil.parseToken(token).setKey(SALT.getBytes());
        // validate包含了verify
        boolean validate = jwt.validate(0);
        log.info("token校验结果：{}", validate);
        return validate;
    }

    /**
     * 获取 token payload
     */
    public static Map<String, Object> getPayload(String token) {
        JWT jwt = JWTUtil.parseToken(token).setKey(SALT.getBytes());
        JSONObject payloads = jwt.getPayloads();
        log.info("token payloads：{}", payloads);
        return payloads;
    }
}

//Junit5
public class JwtUtilTest {
    @Test
    void createToken() {
        Map<String, Object> map = new HashMap<>();
        map.put("userCode", "KD5379");
        map.put("phone", "15865784125");
        String token = JwtUtil.createToken(map);
        JwtUtil.getPayload(token);
        JwtUtil.checkToken(token);
    }
}

17:16:02.659 [main] INFO com.gem.common.jwt.JwtUtil - token创建：eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJwaG9uZSI6IjE1ODY1Nzg0MTI1IiwiZXhwIjoxNzA2OTk0OTYyLCJpYXQiOjE3MDY5NTE3NjIsInVzZXJDb2RlIjoiS0Q1Mzc5In0.5Nb057C9t4dzA8nAUwH6plYzVB9nNorAo6H_ahsYHvo
17:16:02.678 [main] INFO com.gem.common.jwt.JwtUtil - token payloads：{"phone":"15865784125","exp":1706994962,"iat":1706951762,"userCode":"KD5379"}
17:16:02.683 [main] INFO com.gem.common.jwt.JwtUtil - token校验结果：true
```

[↗️使用hutool工具类jwt生成token](https://blog.csdn.net/weixin_45724648/article/details/132169616)



##### auth0 java-jwt

Maven依赖

```xml
<dependency>
    <groupId>com.auth0</groupId>
    <artifactId>java-jwt</artifactId>
    <version>3.14.0</version>
</dependency>
```

参考代码

```java
package com.mashibing.internalcommon.util;


import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTCreator;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.AlgorithmMismatchException;
import com.auth0.jwt.exceptions.SignatureVerificationException;
import com.auth0.jwt.exceptions.TokenExpiredException;
import com.auth0.jwt.interfaces.Claim;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.mashibing.internalcommon.dto.TokenResult;

import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

public class JwtUtils {

    // 盐
    private static final String SIGN = "CPFmsb!@#$$";

    private static final String JWT_KEY_PHONE = "phone";

    // 乘客是1，司机是2
    private static final String JWT_KEY_IDENTITY = "identity";

    // token类型
    private static final String JWT_TOKEN_TYPE = "tokenType";

    private static final String JWT_TOKEN_TIME = "tokenTime";

    // 生成token
    public static String generateToken(String phone, String identity, String tokenType) {
        Map<String, String> map = new HashMap<>();
        map.put(JWT_KEY_PHONE, phone);
        map.put(JWT_KEY_IDENTITY, identity);
        map.put(JWT_TOKEN_TYPE, tokenType);
        // 防止每次生成的token一样。
        map.put(JWT_TOKEN_TIME, Calendar.getInstance().getTime().toString());

        JWTCreator.Builder builder = JWT.create();
        // 整合map
        map.forEach(
                (k, v) -> {
                    builder.withClaim(k, v);
                }
        );
        // 生成 token
        String sign = builder.sign(Algorithm.HMAC256(SIGN));

        return sign;
    }


    // 解析token
    public static TokenResult parseToken(String token) {
        DecodedJWT verify = JWT.require(Algorithm.HMAC256(SIGN)).build().verify(token);
        String phone = verify.getClaim(JWT_KEY_PHONE).asString();
        String identity = verify.getClaim(JWT_KEY_IDENTITY).asString();

        TokenResult tokenResult = new TokenResult();
        tokenResult.setPhone(phone);
        tokenResult.setIdentity(identity);
        return tokenResult;

    }

    /**
     * 校验token，主要判断token是否异常
     *
     * @param token
     * @return
     */
    public static TokenResult checkToken(String token) {
        TokenResult tokenResult = null;
        try {
            tokenResult = JwtUtils.parseToken(token);
        } catch (Exception e) {

        }
        return tokenResult;
    }

    public static void main(String[] args) {
        String s = generatorToken("13910733521", "1", "accessToken");
        System.out.println("生成的token：" + s);
        System.out.println("解析-----------------");
        TokenResult tokenResult = parseToken(s);
        System.out.println("手机号：" + tokenResult.getPhone());
        System.out.println("身份：" + tokenResult.getIdentity());
    }
}

```



### SAML

 (Security Assertion Markup Language)：

**简介**

SAML是一种基于XML的标准，用于在不同的安全域之间交换身份验证和授权数据。SAML通常用于企业间的单点登录和身份管理。

**适用场景**

适用于企业间的单点登录、跨组织的身份验证和授权等场景。



### Kerberos

**简介**

Kerberos是麻省理工学院开发的安全认证系统。也是一种网络身份验证协议，用于在非安全网络中进行身份验证，特别适用于局域网环境。Kerberos提供了强大的身份验证和票据交换机制。

**适用场景**

适用于局域网环境下的身份验证和访问控制。



### UMA

 (User-Managed Access)：

**简介**

UMA是一种授权框架，旨在为用户提供对其个人数据的控制权，允许用户授权第三方访问其个人数据。

**适用场景**

适用于需要用户对其个人数据进行授权管理的场景，如个人数据共享和访问控制等。





## 加解密



## 防反编译
