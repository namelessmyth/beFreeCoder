# 架构设计-解决方案

# 文档说明

本文档主要用于记录所有已知的业务功能的解决方案。同一个业务的解决方案往往不止一种，所以还会列出每一种解决方案的优缺点和适用场景。

**符号说明**：✅代表已发布；🙌代表整理中；↗️代表转载的他人作品

| 文档名称     | 架构设计-解决方案 |
| ------------ | ----------------- |
| 文档分类     | 经验总结-架构设计 |
| 版本号       | 1.0               |
| 最后更新日期 | 2023-12-24        |
| 最后更新人   | Gem Shen          |
| 编制日期     | 2024-02-03        |
| 编制人       | Gem Shen          |



## 文档更新记录

| 版本 | 编制/修改人 | 修改日期   | 备注（原因、进一步的说明等）               |
| --- | --------- | -------- | --------------------------------------- |
| 1.0  | Gem | 2021-02-03 | 初版，使用[ProcessOn思维导图](https://www.processon.com/view/link/608e670f5653bb720e1ffee2)记录 |
| 1.1  | Gem | 2024-02-03 | 开始用文档记录，脑图不适合记录细节和搜索。|



# 文件处理

## PDF处理





## 在线预览

kkFileView



## 在线编辑

### OnlyOffice

[官网文档](https://www.onlyoffice.com/zh/download-docs.aspx#docs-community)，

缺点：不开源，社区版最大连接数限制20



## 文字识别

### PaddleOcr

[GitHub](https://github.com/PaddlePaddle/PaddleOCR)，[Gitee](https://gitee.com/paddlepaddle/PaddleOCR)。目前主流的OCR库，在国内专业领域认可度相当的⾼。可以识别近80种语⾔，并且识别准确度和速度都非常⾼。

缺点是基于Python，对于没接触过Python的人来说有额外学习成本。



### Tess4J

Tess4J可以和Spring Boot做集成来实现OCR（光学字符识别），以识别出本地和远程图片中的文字。[↗️原文链接](https://mp.weixin.qq.com/s/dWNrGc3MFispISC_3IB7iA)



# 远程调用

## RMI

RMI是Java平台上用于实现远程方法调用的机制。它允许一个Java虚拟机上的对象调用另一个Java虚拟机上的对象的方法。RMI使用Java的序列化机制来在网络上传输对象，并提供了远程对象的注册和查找服务。

适用场景

RMI适用于Java平台上的分布式系统，特别是在构建基于Java的企业级应用程序时比较常用。

优点

RMI提供了简单的远程方法调用机制，易于使用和集成到Java应用程序中。它提供了强类型的远程调用，并且对Java对象的序列化和反序列化进行了封装。

缺点

RMI主要局限于Java平台，不太适用于多语言环境。它也可能存在性能问题，并且需要处理分布式系统中的一些复杂性。



## Web Service

Web Service是一种基于Web的分布式系统通信技术，通常使用HTTP协议进行通信。它可以采用不同的标准，如SOAP（Simple Object Access Protocol）和WSDL（Web Services Description Language）。

适用场景

Web服务适用于跨平台、跨语言的分布式系统集成，通常用于构建面向Internet的分布式系统，如电子商务平台、社交网络等。

优点

Web服务使用标准的HTTP协议进行通信，易于集成到各种不同的平台和语言中。它支持各种不同的消息格式，如XML、JSON等。并且可以通过WSDL描述服务接口，便于服务的发现和使用。

缺点

Web服务在传输效率和性能方面可能不如其他技术。它的消息格式可能较为臃肿，且需要在客户端和服务端进行较多的XML解析和处理。



## Http API

HTTP API是指基于HTTP协议的应用程序接口，它使用HTTP请求方法（如GET、POST、PUT、DELETE等）来实现对资源的操作。HTTP API可以使用不同的消息格式，如JSON、XML等。

适用场景：HTTP API适用于构建面向Web的应用程序接口，如移动应用程序后端服务、云服务等。

优点：HTTP API使用标准的HTTP协议进行通信，易于集成到各种不同的平台和语言中。它可以使用轻量级的消息格式，如JSON，具有较高的传输效率和性能。

缺点：HTTP API可能需要在客户端和服务端进行较多的自定义逻辑处理，以满足特定的业务需求。它的设计和实现可能较为灵活，需要开发者自行定义API的规范和约定。



### Restful API

Restful API是一种基于REST架构风格的HTTP API的实现方式。因此，Restful API可以看作是HTTP API的一种特定形式，它遵循了REST的设计原则和约定。

使用REST（Representational State Transfer）架构风格设计的API，它使用HTTP协议进行通信，通常使用JSON或XML等轻量级的消息格式进行数据交换。RESTful API遵循一组约定和原则，如资源的标识、统一接口、状态转移等，以实现系统的可伸缩性、简单性和性能。

适用场景

Restful API适用于构建轻量级、高性能、可伸缩的分布式系统，通常用于构建互联网上的Web API，如移动应用程序后端服务、云服务等。

优点

Restful API使用标准的HTTP协议进行通信，易于集成到各种不同的平台和语言中。它使用轻量级的消息格式，如JSON，具有较高的传输效率和性能。并且Restful API的设计风格简单清晰，易于理解和使用。

缺点

Restful API可能对资源的描述较为简单，不太适用于复杂的业务逻辑。它也可能需要客户端和服务端进行较多的自定义逻辑处理，以满足特定的业务需求。



### 实现方式

#### RestTemplate

RestTemplate是Spring框架提供的用于访问RESTful服务的模板类，它封装了HTTP请求的发送和响应的处理，简化了与RESTful服务的交互。以下是使用RestTemplate的基本步骤和参考代码：

1. 创建RestTemplate实例： 首先，需要创建一个RestTemplate实例。在Spring Boot应用程序中，可以通过注入RestTemplate Bean的方式来使用，或者直接使用RestTemplate的构造函数创建实例。

```java
import org.springframework.web.client.RestTemplate;

// 在Spring Boot应用程序中注入RestTemplate Bean
@Configuration
public class AppConfig {
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

发送GET请求： 使用RestTemplate发送GET请求，获取远程服务的资源。

```java
import org.springframework.web.client.RestTemplate;

RestTemplate restTemplate = new RestTemplate();
String url = "http://example.com/api/resource";
String response = restTemplate.getForObject(url, String.class);
System.out.println(response);
```

发送POST请求： 使用RestTemplate发送POST请求，向远程服务提交数据。

```java
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.web.client.RestTemplate;

RestTemplate restTemplate = new RestTemplate();
String url = "http://example.com/api/resource";
HttpHeaders headers = new HttpHeaders();
headers.setContentType(MediaType.APPLICATION_JSON);
String requestBody = "{\"key\": \"value\"}";
HttpEntity<String> requestEntity = new HttpEntity<>(requestBody, headers);
String response = restTemplate.postForObject(url, requestEntity, String.class);
System.out.println(response);
```

发送带有参数的GET请求： 使用RestTemplate发送带有参数的GET请求。

```java
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

RestTemplate restTemplate = new RestTemplate();
String url = "http://example.com/api/resource";
UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(url)
        .queryParam("param1", "value1")
        .queryParam("param2", "value2");
String finalUrl = builder.toUriString();
String response = restTemplate.getForObject(finalUrl, String.class);
System.out.println(response);
```

getForEntity方法用于发送GET请求，并返回一个ResponseEntity对象，该对象包含完整的HTTP响应信息，包括状态码、头部信息、响应主体等。使用getForEntity方法可以更灵活地处理HTTP响应的各个部分。

```java
String url = "http://example.com/api/resource";
ResponseEntity<MyObject> responseEntity = restTemplate.getForEntity(url, MyObject.class);
MyObject myObject = responseEntity.getBody();
HttpStatus statusCode = responseEntity.getStatusCode();
```



#### Hutool HttpUtil

Hutool是一个Java工具类库，提供了丰富的工具方法和组件，包括对HTTP请求的封装。下面是使用Hutool调用RESTful API的基本步骤和参考代码：

1. 添加Hutool依赖： 首先，需要在项目的Maven或Gradle配置文件中添加Hutool的依赖。

Maven依赖：

```xml
<dependency>
    <groupId>cn.hutool</groupId>
    <artifactId>hutool-http</artifactId>
    <version>5.8.5</version>
</dependency>
```

Gradle依赖：

```groovy
implementation 'cn.hutool:hutool-http:5.7.7'
```

1. 发送GET请求： 使用Hutool发送GET请求，获取远程服务的资源。

```java
import cn.hutool.http.HttpUtil;

String url = "http://example.com/api/resource";
String response = HttpUtil.get(url);
System.out.println(response);
```

1. 发送POST请求： 使用Hutool发送POST请求，向远程服务提交数据。

```java
import cn.hutool.http.HttpRequest;
import cn.hutool.http.HttpResponse;

String url = "http://example.com/api/resource";
String requestBody = "{\"key\": \"value\"}";
HttpRequest request = HttpRequest.post(url)
        .body(requestBody)
        .header("Content-Type", "application/json");
HttpResponse response = request.execute();
String result = response.body();
System.out.println(result);
```

1. 发送带有参数的GET请求： 使用Hutool发送带有参数的GET请求。

```java
import cn.hutool.http.HttpUtil;

String url = "http://example.com/api/resource";
String response = HttpUtil.get(url, null, null);
System.out.println(response);
```

这些是使用Hutool调用RESTful API的基本步骤和示例代码。通过Hutool，可以方便地与远程的RESTful服务进行交互，发送HTTP请求并处理响应。 Hutool提供了丰富的API，可以满足各种HTTP请求的需求。



#### Apache HttpClient

Apache HttpClient是Apache软件基金会提供的一个Java HTTP客户端库，用于发送HTTP请求和处理响应。以下是使用Apache HttpClient调用RESTful API的示例代码：

```java
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import org.apache.http.HttpResponse;

HttpClient httpClient = HttpClients.createDefault();
String url = "http://example.com/api/resource";
HttpGet httpGet = new HttpGet(url);
HttpResponse response = httpClient.execute(httpGet);
String result = EntityUtils.toString(response.getEntity());
System.out.println(result);
```



#### OkHttp

OkHttp是Square公司开发的一个高效的HTTP客户端库，适用于Android和Java应用程序。以下是使用OkHttp调用RESTful API的示例代码：

```java
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

OkHttpClient client = new OkHttpClient();
String url = "http://example.com/api/resource";
Request request = new Request.Builder()
        .url(url)
        .build();
Response response = client.newCall(request).execute();
String result = response.body().string();
System.out.println(result);
```



#### Unirest

Unirest是一个简单而优雅的HTTP客户端库，提供了易于使用的API和链式调用的方式。以下是使用Unirest调用RESTful API的示例代码：

```java
import kong.unirest.HttpResponse;
import kong.unirest.Unirest;

String url = "http://example.com/api/resource";
HttpResponse<String> response = Unirest.get(url).asString();
String result = response.getBody();
System.out.println(result);
```

这些工具类都提供了丰富的API和功能，可以用于发送HTTP请求、处理响应、设置请求头、处理异常等。根据具体的需求和偏好，可以选择合适的工具类来调用RESTful API



# 消息通知

## 短信

如阿里云短信服务、腾讯云短信服务、



## 电子邮件

SendGrid邮件服务



## 企业微信



## 微信



# 规则引擎

### liteflow

**使用场景**

[官网](https://liteflow.cc/pages/5816c5/#%E5%89%8D%E8%A8%80)

在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统RPC调用等等。时间一长，项目几经易手，维护成本就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。

如何打破僵局？LiteFlow为解耦逻辑而生，为编排而生，在使用LiteFlow之后，你会发现打造一个低耦合，灵活的系统会变得易如反掌！

优势

如果你要对复杂业务逻辑进行新写或者重构，用LiteFlow最合适不过。它是一个编排式的规则引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件。

利用LiteFlow，可以将瀑布流式的代码，转变成以组件为核心概念的代码结构，这种结构的好处是可以任意编排，组件与组件之间是解耦的，组件可以用脚本来定义，组件之间的流转全靠规则来驱动。LiteFlow拥有开源规则引擎最为简单的DSL语法。十分钟就可上手。



# 安全

## 认证授权

认证和授权的区别在于认证是验证用户身份的过程，而授权是确定用户被允许执行的操作或访问的资源的过程。

下面将介绍认证授权相关的框架与协议



### OAuth 2.0

**简介**

OAuth 2.0是一种认证授权框架，用于授权第三方应用访问用户资源，而无需提供用户的凭证。它允许用户授权第三方应用代表用户进行访问，同时保护用户的凭证不被第三方应用获取。

**适用场景**

适用于Web应用、移动应用和API访问控制等场景。

**应用场景**

OAuth 2.0广泛应用于各种场景，以下是一些常见的应用场景：

- **社交登录**：用户可以使用他们的社交媒体帐户登录到其他应用程序，例如使用Google或Facebook登录。
- **API访问**：开发人员可以使用OAuth 2.0来访问第三方API，例如使用GitHub API或Twitter API。
- **单点登录**：用户可以使用一个身份验证提供商登录到多个相关的应用程序，而无需多次输入凭证。
- **授权访问**：应用程序可以请求用户授权访问其资源，例如Google云存储或Dropbox。
- **移动应用授权**：移动应用程序可以安全地请求访问用户数据，如照片、联系人或位置信息。



### OpenID Connect

**简介**

OpenID Connect（OIDC）是建立在OAuth 2.0之上的身份验证协议，它扩展了OAuth 2.0，提供了对用户身份验证的支持。OpenID Connect使用OAuth 2.0的授权流程来获取访问令牌，并在此基础上添加了身份令牌（id token）来验证用户的身份。因此，OpenID Connect不仅提供了授权，还提供了对用户身份的验证和认证。

**适用场景**

适用于需要进行用户身份验证，并获取用户身份信息的场景，如单点登录、用户认证等。



#### JWT

JWT（JSON Web Token）是一种用于在网络间安全传输声明的开放标准（RFC 7519），它通常用于在OAuth 2.0和OpenID Connect中传递访问令牌和身份令牌。JWT是一种紧凑且自包含的方式来表示信息，它使用数字签名或加密来验证其完整性和真实性。[在线演示](https://jwt.io/)。

##### Hutool JwtUtil

Maven依赖

```xml
<dependency>
    <groupId>cn.hutool</groupId>
    <artifactId>hutool-all</artifactId>
    <version>5.8.21</version>
</dependency>
```

参考代码

```java
package com.gem.common.jwt;

import cn.hutool.core.date.DateField;
import cn.hutool.core.date.DateTime;
import cn.hutool.json.JSONObject;
import cn.hutool.jwt.JWT;
import cn.hutool.jwt.JWTPayload;
import cn.hutool.jwt.JWTUtil;
import lombok.extern.slf4j.Slf4j;

import java.util.Map;

@Slf4j
public class JwtUtil {
    /**
     * 盐，很重要，不能泄漏，建议放到配置文件中
     */
    private static final String SALT = "salt-test-123456";

    public static String createToken(Map<String, Object> data) {
        DateTime now = DateTime.now();
        DateTime expTime = now.offsetNew(DateField.HOUR, 12);
        // 生效时间。
        data.put(JWTPayload.ISSUED_AT, now);
        // 失效时间。
        data.put(JWTPayload.EXPIRES_AT, expTime);
        String token = JWTUtil.createToken(data, SALT.getBytes());
        log.info("token创建：{}", token);
        return token;
    }

    /**
     * 校验token是否有效
     */
    public static boolean checkToken(String token) {	
        JWT jwt = JWTUtil.parseToken(token).setKey(SALT.getBytes());
        // validate包含了verify
        boolean validate = jwt.validate(0);
        log.info("token校验结果：{}", validate);
        return validate;
    }

    /**
     * 获取 token payload
     */
    public static Map<String, Object> getPayload(String token) {
        JWT jwt = JWTUtil.parseToken(token).setKey(SALT.getBytes());
        JSONObject payloads = jwt.getPayloads();
        log.info("token payloads：{}", payloads);
        return payloads;
    }
}

//Junit5
public class JwtUtilTest {
    @Test
    void createToken() {
        Map<String, Object> map = new HashMap<>();
        map.put("userCode", "KD5379");
        map.put("phone", "15865784125");
        String token = JwtUtil.createToken(map);
        JwtUtil.getPayload(token);
        JwtUtil.checkToken(token);
    }
}

17:16:02.659 [main] INFO com.gem.common.jwt.JwtUtil - token创建：eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJwaG9uZSI6IjE1ODY1Nzg0MTI1IiwiZXhwIjoxNzA2OTk0OTYyLCJpYXQiOjE3MDY5NTE3NjIsInVzZXJDb2RlIjoiS0Q1Mzc5In0.5Nb057C9t4dzA8nAUwH6plYzVB9nNorAo6H_ahsYHvo
17:16:02.678 [main] INFO com.gem.common.jwt.JwtUtil - token payloads：{"phone":"15865784125","exp":1706994962,"iat":1706951762,"userCode":"KD5379"}
17:16:02.683 [main] INFO com.gem.common.jwt.JwtUtil - token校验结果：true
```

[↗️使用hutool工具类jwt生成token](https://blog.csdn.net/weixin_45724648/article/details/132169616)



##### auth0 java-jwt

Maven依赖

```xml
<dependency>
    <groupId>com.auth0</groupId>
    <artifactId>java-jwt</artifactId>
    <version>3.14.0</version>
</dependency>
```

参考代码

```java
package com.mashibing.internalcommon.util;


import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTCreator;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.AlgorithmMismatchException;
import com.auth0.jwt.exceptions.SignatureVerificationException;
import com.auth0.jwt.exceptions.TokenExpiredException;
import com.auth0.jwt.interfaces.Claim;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.mashibing.internalcommon.dto.TokenResult;

import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

public class JwtUtils {

    // 盐
    private static final String SIGN = "CPFmsb!@#$$";

    private static final String JWT_KEY_PHONE = "phone";

    // 乘客是1，司机是2
    private static final String JWT_KEY_IDENTITY = "identity";

    // token类型
    private static final String JWT_TOKEN_TYPE = "tokenType";

    private static final String JWT_TOKEN_TIME = "tokenTime";

    // 生成token
    public static String generateToken(String phone, String identity, String tokenType) {
        Map<String, String> map = new HashMap<>();
        map.put(JWT_KEY_PHONE, phone);
        map.put(JWT_KEY_IDENTITY, identity);
        map.put(JWT_TOKEN_TYPE, tokenType);
        // 防止每次生成的token一样。
        map.put(JWT_TOKEN_TIME, Calendar.getInstance().getTime().toString());

        JWTCreator.Builder builder = JWT.create();
        // 整合map
        map.forEach(
                (k, v) -> {
                    builder.withClaim(k, v);
                }
        );
        // 生成 token
        String sign = builder.sign(Algorithm.HMAC256(SIGN));

        return sign;
    }


    // 解析token
    public static TokenResult parseToken(String token) {
        DecodedJWT verify = JWT.require(Algorithm.HMAC256(SIGN)).build().verify(token);
        String phone = verify.getClaim(JWT_KEY_PHONE).asString();
        String identity = verify.getClaim(JWT_KEY_IDENTITY).asString();

        TokenResult tokenResult = new TokenResult();
        tokenResult.setPhone(phone);
        tokenResult.setIdentity(identity);
        return tokenResult;

    }

    /**
     * 校验token，主要判断token是否异常
     *
     * @param token
     * @return
     */
    public static TokenResult checkToken(String token) {
        TokenResult tokenResult = null;
        try {
            tokenResult = JwtUtils.parseToken(token);
        } catch (Exception e) {

        }
        return tokenResult;
    }

    public static void main(String[] args) {
        String s = generatorToken("13910733521", "1", "accessToken");
        System.out.println("生成的token：" + s);
        System.out.println("解析-----------------");
        TokenResult tokenResult = parseToken(s);
        System.out.println("手机号：" + tokenResult.getPhone());
        System.out.println("身份：" + tokenResult.getIdentity());
    }
}

```



### SAML

 (Security Assertion Markup Language)：

**简介**

SAML是一种基于XML的标准，用于在不同的安全域之间交换身份验证和授权数据。SAML通常用于企业间的单点登录和身份管理。

**适用场景**

适用于企业间的单点登录、跨组织的身份验证和授权等场景。



### Kerberos

**简介**

Kerberos是麻省理工学院开发的安全认证系统。也是一种网络身份验证协议，用于在非安全网络中进行身份验证，特别适用于局域网环境。Kerberos提供了强大的身份验证和票据交换机制。

**适用场景**

适用于局域网环境下的身份验证和访问控制。



### UMA

 (User-Managed Access)：

**简介**

UMA是一种授权框架，旨在为用户提供对其个人数据的控制权，允许用户授权第三方访问其个人数据。

**适用场景**

适用于需要用户对其个人数据进行授权管理的场景，如个人数据共享和访问控制等。





## 加解密



## 防反编译
