# 项目实战-飞滴出行

# 项目总览

## 功能模块

以下是整个系统要实现的功能模块：

- 乘客端功能
    - 注册/登录
    - 预估价格
    - 乘客下单
    - 系统派单
    - 乘客支付
    - 乘客评价
- 司机端功能
    - 注册/登录
    - 司机听单
    - 司机抢单
    - 订单流转
    - 发起收款
- BOSS端功能
    - 用户管理
    - 司机管理
    - 车辆管理
    - 司机和车辆关系管理



## 业务架构

### 架构图

![image-20240126165323135](项目实战-Java-网约车.assets/image-20240126165323135.jpg)

### 架构介绍

- 前端展示层
    - 官网PC/wap
    - 乘客端
    - 司机端
    - 小程序端
    - 运营平台boss
    - 开放平台API
- 网络接入层（请求进入系统的第一道防线，鉴权，黑名单限制，屏蔽非法请求）
    - 网关
    - 负载均衡
- 业务服务层（直接处理客户端请求）
    - api-passenger（乘客）
    - api-driver（司机）
    - api-boss（管理员）
    - ...以上每个服务，都支持集群
- 能力服务层（通用能力服务）
    - service-user
        - 查询用户信息（例如：是否在黑名单里，权限校验，状态等等）
    - service-order
        - 创建，查询，取消订单
    - service-pay
    - ...上述服务集群
    - 中间件
- 存储层（数据库）
    - MySQL
- 运行环境
    - 宿主服务器
    - Vmware，docker，K8s等
- 贯穿整个项目
    - 日志
    - 权限



## 项目技术

前       端：uni-app（Vue）

数 据  库：MySQL

缓       存：Redis

注册中心：Nacos

配置中心：Nacos

网       关：Spring Cloud Gateway

熔断限流：Spring Cloud Alibaba Sentinel

服务监控：Spring Cloud Sleuth、Spring Cloud zipkin

分布式锁：Redisson

分布式事物：Alibaba 的 Seata

服务通信：SSE (server sent event)



## 网约车国家标准

具体参考：网络预约出租汽车-总体技术要求.pdf

国家要求网约车平台定时上报信息给监管部门，并且规定了报文格式和报文字段。设计表时可做参考。

例如：

CompanyId，V32，公司(/平台)标识(部平台统一分配网约车平台公司标识)

Source，F8，消息来源标识(部平台统一分配消息的数据链路来源标识)

IPCType，业务接口代码,见具体接口定义



## 项目设计原则

### 单一职责原则

每一个微服务所承担的职责应尽可能担一。

例如：订单服务，地图服务。虽然业务上这个功能紧密相连。但如果放在一起会带来服务耦合。开发，维护，发布时可能会互相影响。

如果分成2个服务，地图服务还可以作为公共服务给更多服务调用。



### 高内聚原则

高内聚是指应该尽量将关系紧密的功能和模块放在一起，使它们形成一个紧密耦合的单元。该单元内部的各个部分相互依赖，协同完成一定的功能。这样对外部模块的影响和干扰相对较小，能够提高系统的可靠性和可维护性，减少系统出现故障的概率。

例如：订单管理服务，订单金额统计服务。订单金额统计时和订单信息紧密相连。每次只要改订单管理都可能会影响统计服务。这2个行为依赖的数据源也是一样的，像这样的服务就适合放在一起的。如果分成2个服务就变成了网络调用，而且改一个还得通知另一个及时修改，反而更容易出错和不好维护。



### 低耦合原则

低耦合是指各个服务之间相互独立，彼此之间的耦合度尽可能地低，每个模块之间的关联程度尽量小。

低耦合是为了提高系统的灵活性和可扩展性，降低系统中某个模块发生变化对其他模块造成的影响，从而减少系统维护和扩展的难度。



### 粒度把控原则

首先粒度把控没有绝对的标准，适合最重要。每次考虑服务拆分或者确定服务边界时，都应该考虑这么设计之后结果，是否已最大可能符合高内聚低耦合的原则。同时也要考虑业务和项目背景

例如：设计订单服务时，哪些功能应该包含在这个服务中，哪些又应该拆分到另一个服务中。有些公司就会将订单和地图服务绑定在一起，因为他们并没有其他服务要用到地图，拆分成2个会增加开发和维护成本，所以这样做对他们最好。但有些公司就不会放在一起。



### AKF划分原则

#### 背景

当我们需要分布式系统提供更强的性能时，该怎样扩展系统呢？

什么时候该加机器？什么时候该重构代码？扩容时，究竟该选择哈希算法还是最小连接数算法，才能有效提升性能？

在面对Scalability（可扩展性或可伸缩性）问题时，我们必须有一个系统的方法论，才能应对日益复杂的分布式系统。而AKF划分原则就是来处理这个的，它定义了扩展系统的 3 个维度，我们可以综合使用它们来优化性能。

#### 介绍

AKF 立方体，它在《The Art of Scalability》一书中被首次提出，旨在提供一个系统化的扩展思路。AKF 把系统扩展分为以下三个维度：

X 轴：直接水平复制应用进程来扩展系统。

Y 轴：将功能拆分出来扩展系统。

Z 轴：通常是指基于用户进行数据分片和分治。



#### X轴

这个方向的扩展是指将同样的服务和数据放在多个并行的服务器节点上，加入负载均衡，当任意一个节点出现故障，系统仍然可以访问。提升整体服务的可用性和吞吐量问题。有个前提是：服务属于无状态服务。

```mermaid
flowchart LR
client-->bal["负载均衡"]-->cluster-->DB
subgraph cluster["集群"]
服务节点1
服务节点2
服务节点3
end
```

优点：

开发成本近乎为零，实施起来速度快！搭建好负载均衡后，只要在新的服务器上复制程序，就可以让新的服务节点分担请求流量，而且不会影响事务的处理。

缺点：

只能扩展无状态服务，会对数据库造成压力，当单个服务节点或者数据库出现性能瓶颈时，就需要从其他轴开始优化了。



#### Y轴

当沿着X轴扩展系统，性能逐渐到达瓶颈。也可以一开始就按照Y轴进行拆分。此时可以考虑拆分系统功能，使得各服务的功能、职责更细，从而提升系统的效率。拆分的时候有2个维度，按动词拆或者按名词拆。

##### 按动词拆

例如：按服务的读写操作进行拆分，将数据库改为主从复制结构，主库支持读写（也可以只支持写），从库只支持读SQL。这样，主库的压力就会明显下降，系统整体性能得以提升。同时如果读的性能出现瓶颈，也可以从X轴的方向继续扩展读库。即增加从库1，从库2，从库3...如下图：

```mermaid
flowchart LR
client-->bal["负载均衡"]-->cluster-->|写请求|主库
subgraph cluster["集群"]
服务节点1
服务节点2
服务节点3
end

subgraph DB["主从复制"]
主库-->|同步数据|从库1
主库-->|同步数据|从库2
end

cluster-->|读请求|从库1
cluster-->|读请求|从库2
```

##### 按名词拆

例如：将一个大服务，拆分成订单服务，地图服务，用户服务等等小服务。每一个服务都有自己的独立数据库。当单个小服务吞吐量及可用性不足时继续沿X轴扩展。即增加订单服务1，2，3...

```mermaid
flowchart LR
client-->订单服务-->订单库
client-->地图服务-->地图库
client-->用户服务-->用户库
```



缺点：

Y轴的扩展比X轴的扩展成本大很多，需要重构代码。上线部署与维护也更复杂。

如果把一个服务拆分成多个服务也涉及服务间的API调用。

把服务拆分之后的单个服务依然可能存在性能问题。



#### Z轴

Z轴扩展通常是指基于请求和用户独特的需求，进行系统划分。可用来扩展数据库也可用于扩展服务。

##### 扩展服务

针对请求用户的地域，例如：北京的用户由北京的服务处理，杭州的用户由杭州服务器处理。

或者按用户组，例如：乘客一个服务，司机一个服务。

##### 扩展数据库

数据库分片，在做某些查询的时候，查询指令被送给每一个分片，然后分别查询，最终获得的结果聚合之后返回。

常见的分片方式

- 业务数据按时间分表，例如：按照年或月
- 业务数据按用户user_id的模数或hash进行划分

```mermaid
flowchart LR
client-->balance[负载均衡]
balance-->北京用户-->北京服务
balance-->杭州用户-->杭州服务
balance-->广州用户-->广州服务
```

